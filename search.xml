<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IP获取及定位</title>
      <link href="/2019/10/11/attark/findip/"/>
      <url>/2019/10/11/attark/findip/</url>
      
        <content type="html"><![CDATA[<h3 id="NTRQQ插件集成"><a href="#NTRQQ插件集成" class="headerlink" title="NTRQQ插件集成"></a>NTRQQ插件集成</h3><p>NtrQQ可以可以点亮各种钻的图标，本功能可本地开启所有业务图标（别人不可见），开启此功能后还可享受绿钻的特权：比如在群内可分享歌曲给你的群友。QQ越做越大，内存占用越来越高，那点小内存根本不够用，打开内存整理这个功能可以自动定时定点整理内存。平时有很多QQ自带组件根本就用不到，您可以自己动手借助本软件的插件过滤功能关掉  </p><p>总之这个插件，非常强，能够破解掉QQ上很多权限，最主要的是它显示IP的功能，通过远程对话，或者在线传输文件就能获取到对方的IP地址，有了IP地址就能对其定位，找到对方大概的位置，其实也可以通过一些抓包软件抓到对方的外网IP，但那并不适合新手。这个插件在一年前就停止了更新（涉嫌侵权），但留下来的插件被其他大牛继续优化更新。<br><a href="http://www.carrotchou.blog/17112.html" target="_blank" rel="noopener">ntrqq插件</a>  </p><p><a href="https://www.lanzous.com/i66ured" target="_blank" rel="noopener">下载</a><br>插件内包含使用说明文档，看文档进行操作。<br>细节操作自行挖掘，因：（散播教程侵犯他人隐私）<br><img src="http://img.ahdy.top/2019-10-11_112309.png" alt="集成成功演示图"></p><h3 id="木子李QQ"><a href="#木子李QQ" class="headerlink" title="木子李QQ"></a>木子李QQ</h3><p>这可能是一个笔名为木子李的人利用NTRQQ插件集成的QQ，但是自NTRQQ站长被腾讯告了之后，今年木子李QQ停止了对显示IP功能的开放，但其它功能也非常好，可以百度了解一下。  </p><h3 id="利用地图开放接口定位"><a href="#利用地图开放接口定位" class="headerlink" title="利用地图开放接口定位"></a>利用地图开放接口定位</h3><p>以百度地图为例子，首先百度一下，搜索百度地图开放平台，登陆百度账号。<br><img src="http://img.ahdy.top/2019-10-11_101554.png" alt><br>在上方功能与服务当中，选择定位<br><img src="http://img.ahdy.top/2019-10-11_101845.png" alt><br>查看文档使用<br><img src="http://img.ahdy.top/2019-10-11_105344.png" alt><br><img src="http://img.ahdy.top/2019-10-11_105424.png" alt><br><img src="http://img.ahdy.top/2019-10-11_105713.png" alt="效果图"><br>经纬度都有了，是不是够精确了？其实并不是，这个点只能算是阵眼。至于它网络的覆盖面积有多大，还是个谜！</p><h3 id="IP地址查询"><a href="#IP地址查询" class="headerlink" title="IP地址查询"></a>IP地址查询</h3><p>现在有很都查ip的工具，百度搜索精准IP查询，当然这些网站都具有时效性，说不定哪时候就访问不到了<br><a href="http://chaipip.com/ip.php" target="_blank" rel="noopener">精准查询</a>   </p>]]></content>
      
      
      <categories>
          
          <category> IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> 定位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>账号是如何被盗的？</title>
      <link href="/2019/10/09/attark/websafty/"/>
      <url>/2019/10/09/attark/websafty/</url>
      
        <content type="html"><![CDATA[<h3 id="被神化的黑客"><a href="#被神化的黑客" class="headerlink" title="被神化的黑客"></a>被神化的黑客</h3><p>在这个信息时代，黑客这个名词已经被抽象化，原因是真正的黑客十分稀少，加上黑客行为非常神秘，各种小学生行为的夸大，黑客最终被神化，成为万能侠，背锅侠。</p><h3 id="盗号有多难"><a href="#盗号有多难" class="headerlink" title="盗号有多难"></a>盗号有多难</h3><p>以腾讯的QQ为例，早在2005年以前，是可以通过数据字典试出QQ的密码，但之后验证码机制的出现使得这种方法暴毙，账号的密码都是存放在数据库当中的，hacker不会担着这么大风险，去搬倒腾讯，阿里的服务器，和法律对着干，当然最主要的原因是没有那个水平，所以黑进什么什么管理系统，基本是无稽之谈。在传输过程中，密码会被加密，以密文形式存进数据库，至于是什么加密方式，还要进行分析，反编译，解算，所以就算hacker暴库了很多用户数据，也不会对用户造成直接损害。这就体现了设置密码的技术，设置密码其实也是一门艺术，尽量使用组合密码，不要设置的过于简单，比如大小写字母+数字+特殊符号，这样的密码经过加密后一般是无法被破解的！</p><h4 id="不要把多个账户密码设置成同一个！"><a href="#不要把多个账户密码设置成同一个！" class="headerlink" title="不要把多个账户密码设置成同一个！"></a>不要把多个账户密码设置成同一个！</h4><p>这个概念在安全领域叫做撞库，就是你的一个密码泄露，可能会导致多个账号丢失，其实真正hacker是需要会很多东西的，能被成为hacker的人那得是计算机领域的天才！他需要会各种编程语言，能够制造木马，编写想要的蠕虫，同时精通算法，心理学，密码学，社会工程学，法律等，才能做到游走于刀尖之上。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近，经常看到很多人微信，QQ号被盗，盗号者利用人际关系进行钱财诈骗，先不说安全意识的问题，账号被盗一般跟个人使用有直接关系，可能是受到某种诱惑，好奇心的左右，为什么这么说，因为80%的账号密码的泄露都是因为钓鱼网站。</p><h3 id="钓鱼网站"><a href="#钓鱼网站" class="headerlink" title="钓鱼网站"></a>钓鱼网站</h3><p>这是一个非常形象的词，通常钓鱼网站的页面做的非常逼真，能够与官方网站媲美，达到以假乱真（当然也有做的很垃圾的），一般点进去条鱼网站不做任何操作，账号不会被盗，但是当用户输入了账号，密码登陆才能领取某些奖励的时候，你所输入的账号密码就会被该网站的后台记录，他轻而易举的得到了你的账号密码，所以一般像什么中大奖了，免费送点卷领皮肤，这里面的照片是你吗？这都是高危词！还要那些来历不明的连接，来历不明的活动，让扫二维码的，一律不要贪图小便宜！就记住一句话，天上不会掉馅饼，有也不会砸到你。嗯，没错！</p><h3 id="木马"><a href="#木马" class="headerlink" title="木马"></a>木马</h3><p>木马这个词的由来就是，经典的特洛伊木马，从内部打破防御，有些木马潜行的非常深，这个东西就像人体的病毒一样，说不定哪个时候就会爆发，对于木马的防范，只能提高警惕，不要乱下载东西，这样就能最大可能的减少被植入木马的风险，当然现在的杀毒软件都很厉害，如果一个木马能过得了毒杀，那…确实就算你倒霉！！毕竟病毒库这个东西，是定期更新的。</p><h3 id="嗅探"><a href="#嗅探" class="headerlink" title="嗅探"></a>嗅探</h3><p>这个词一般针对于局域网内，嗅探与监听通常结合使用，这类安全隐患主要作用于公共场合（危害极大），比如免费wifi，这类WiFi可以是被设置好的陷阱，通过某些工具，就能对流经路由器的数据进行抓取，比如浏览那些网站，账号密码，一些文本信息，都会被抓取到本地，说到这个有点像大数据的爬虫，其实不然，现在很多软件在安装的时候就已经被授权，可以读取用户的信息，大数据采集这些信息，就实现了针对用户的推送，比如，你百度搜个物品，打开淘宝发现淘宝给你推送了这类商品，然后再打开抖音，发现抖音也给你推类似的视频广告，我不知到这是否算是侵犯了用户的隐私，但用户的日常行为确实在互联网当中是透明的，希望未来能够遵循GDPR的规则合法采集数据。</p><h3 id="服务商的阴谋"><a href="#服务商的阴谋" class="headerlink" title="服务商的阴谋"></a>服务商的阴谋</h3><p>现在使用任何软件基本上都需要注册，注册过程其实变向丢失了你的个人信息，这些服务商可以变卖你的个人信息，有时候注册了一些litter软件，推销信息多了，广告信息也多了，卖保险，卖房电话经常打来，说出来你可能不信，推销，骚扰电话占据了我大片童话记录，我与他们之间的联系也非常密切，典型的就是拼刀刀砍价，什么就差你一刀……</p><h4 id="这个世界-想要得到什么，就要付出一些什么，很真实！"><a href="#这个世界-想要得到什么，就要付出一些什么，很真实！" class="headerlink" title="这个世界 想要得到什么，就要付出一些什么，很真实！"></a>这个世界 想要得到什么，就要付出一些什么，很真实！</h4>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开学总结</title>
      <link href="/2019/10/04/draiy/mind/"/>
      <url>/2019/10/04/draiy/mind/</url>
      
        <content type="html"><![CDATA[<p>不知不觉，日子过的很快，转眼间就到了国庆，暑假带给我的浮躁，并没有因此结束，我想着是不是我经不起失败，我内心一旦焦虑，很长一段时间内，都在彷徨的阴影下度过，我常常借酒消愁，一天到晚游戏，睡觉来麻痹自己，我不知道是怎么了，有时的我表现的特别积极，有时候特别消沉，间接性自律，对待事物也是多愁善感~<br>这学期，学校开设了很多课，我的缺点在安卓上得到了质的放大，安卓这门课，开发环境是一个难点，其细节也是安卓最主要的学习点，我本以为，我的缺点会随着年龄的增长慢慢，淡化，但是我想错了，我的马虎不认真，使我屡次碰壁，我为什么遇到困难挫折就选择逃避呢？这也是我经常在反思的问题。学习了一年编程了，我有种越学越不会，学了不想学的感觉，我突然想起那句，任何兴趣变成职业都不将再是兴趣。我可真会给自己的懒惰，逃避困难找理由！……<br>可能我是真的欠揍吧！<br>希望多年以后，再看到这篇日记，我对待事物，从容不迫，不再那么易挫，焦虑。  </p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layui</title>
      <link href="/2019/09/18/framework/layui/"/>
      <url>/2019/09/18/framework/layui/</url>
      
        <content type="html"><![CDATA[<p>时常听老师讲做后端开发的多少都得会点前端，但是写前端的话框架又不能太丑，这时候使用框架让我们在开发上如虎添翼。</p><h3 id="layui框架概述"><a href="#layui框架概述" class="headerlink" title="layui框架概述"></a>layui框架概述</h3><p>很久以前，我为写不出优美的web界面发愁时，杨爽老哥（学长）告诉了我这个框架，俗话说的好，与贤一席话，胜读十年书，在后续的界面开发过程中，这个框架帮我解决了很多问题。<br>据我使用过后的观点，首先它比较容易上手，在操作上比bootstarp要简易，文档通俗易懂。<br>了解更多可以百度一下。</p><h3 id="框架下载"><a href="#框架下载" class="headerlink" title="框架下载"></a>框架下载</h3><p><a href="https://www.layui.com/" target="_blank" rel="noopener">layui官网</a><br>下载好了之后，将文件导入编译器<br><img src="http://img.ahdy.top/2019-09-18_203546.png" alt="演示图"></p><h3 id="如何使用layui"><a href="#如何使用layui" class="headerlink" title="如何使用layui"></a>如何使用layui</h3><p><a href="https://www.layui.com/doc/" target="_blank" rel="noopener">layui官方文档</a>  </p><p><a href="https://pan.baidu.com/s/1NxGgdZhjyX3s8iLNYrP36g#list/path=%2F" target="_blank" rel="noopener">layui视频教程</a></p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>在使用框架时请务必引入相应的js/css<br>在使用文档中相应的模板时请务必将外联css/js，修改为你本地地址。<br>clss需要根据特有的参数引入<br>多框架引入可能会出现索引，布局冲突。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Layui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三级数据库</title>
      <link href="/2019/09/15/draiy/threecomputer/"/>
      <url>/2019/09/15/draiy/threecomputer/</url>
      
        <content type="html"><![CDATA[<h3 id="大难在即"><a href="#大难在即" class="headerlink" title="大难在即"></a>大难在即</h3><p>端午节几天假，浑浑噩噩，玩了几天游戏，突然想起来还有国三没有准备，于是我现在浪子回头，决定立下一个flag。  </p><p>今天是2019年九月十五日，距离考试还有不到一个礼拜，目前我一点题目都没有看，大题基本不会，我决定逆袭一把，你猜我能够成功吗？<br>绝地求生，如果我考完感觉不错的话我会继续更新这篇文章，如果我考过的话，我会分享我几天考过数据库的经验，如果我没有更新那就证明我已经凉了。</p><h3 id="未完待续···"><a href="#未完待续···" class="headerlink" title="未完待续···"></a>未完待续···</h3>]]></content>
      
      
      <categories>
          
          <category> robot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
            <tag> 三级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle安装与连接</title>
      <link href="/2019/09/11/web/mysql4/"/>
      <url>/2019/09/11/web/mysql4/</url>
      
        <content type="html"><![CDATA[<h3 id="Oracle数据库简介"><a href="#Oracle数据库简介" class="headerlink" title="Oracle数据库简介"></a>Oracle数据库简介</h3><p>Oracle也是甲骨文公司的名字，这个公司在IT行业的权重就不用说了呗，该公司推行的Oracle数据库也是十分优秀，在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的、适应高吞吐量的数据库方案。<br>特点：安全,稳定</p><h3 id="Oracle安装"><a href="#Oracle安装" class="headerlink" title="Oracle安装"></a>Oracle安装</h3><p><a href="https://www.oracle.com/technetwork/cn/database/enterprise-edition/downloads/oracle12c-windows-3633015-zhs.html" target="_blank" rel="noopener">官网安装地址</a><br>需要注意的两点。  </p><ol><li>需要注册登陆oracle  </li><li>需要接受协议才能下载<br><img src="http://img.ahdy.top/2019-09-11_143417.png" alt><br>下载解压好如下图，选择.exe文件就能安装，最好退出360，关闭防火墙等，以防出现意外！<br><img src="http://img.ahdy.top/2019-09-11_144707.png" alt><br><img src="http://img.ahdy.top/2019-09-11_145321.png" alt><br><img src="http://img.ahdy.top/2019-09-11_145528.png" alt><br><img src="http://img.ahdy.top/2019-09-11_145721.png" alt><br><img src="http://img.ahdy.top/2019-09-11_151035.png" alt><br><img src="http://img.ahdy.top/2019-09-11_151104.png" alt></li></ol><p><img src="http://img.ahdy.top/2019-09-11_151254.png" alt><br><img src="http://img.ahdy.top/2019-09-11_151132.png" alt><br><img src="http://img.ahdy.top/2019-09-11_151500.png" alt><br><img src="http://img.ahdy.top/2019-09-11_151543.png" alt><br><img src="http://img.ahdy.top/2019-09-11_151629.png" alt><br><img src="http://img.ahdy.top/2019-09-11_151727.png" alt><br><img src="http://img.ahdy.top/2019-09-11_151852.png" alt><br><img src="http://img.ahdy.top/2019-09-11_151904.png" alt><br><img src="http://img.ahdy.top/2019-09-11_152011.png" alt><br><img src="http://img.ahdy.top/2019-09-11_152111.png" alt><br><img src="http://img.ahdy.top/2019-09-11_152209.png" alt><br><img src="http://img.ahdy.top/2019-09-11_152448.png" alt><br><img src="http://img.ahdy.top/2019-09-11_152629.png" alt><br><img src="http://img.ahdy.top/2019-09-11_152756.png" alt></p><h4 id="先决条件可以选择忽略！"><a href="#先决条件可以选择忽略！" class="headerlink" title="先决条件可以选择忽略！"></a>先决条件可以选择忽略！</h4><p><img src="http://img.ahdy.top/2019-09-11_165410.png" alt><br><img src="http://img.ahdy.top/2019-09-11_165206.png" alt></p><h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>该过程非常漫长······给我等死了都！！！<br><img src="http://img.ahdy.top/2019-09-11_170004.png" alt></p><h4 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h4><p><img src="http://img.ahdy.top/2019-09-11_172612.png" alt></p><h4 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h4><p>打开开始菜单，最近添加，找到sql plus，打开后输入用户名及密码<br><img src="http://img.ahdy.top/2019-09-11_175317.png" alt><br>出现连接到xxxxx之后oracle已经彻底安装成功！<br>注意：这里的用户名是orcale自带的超级管理员，密码是你在安装过程中中设置的任何用户通用密码。</p><h3 id="密码修改"><a href="#密码修改" class="headerlink" title="密码修改"></a>密码修改</h3><p><a href="https://www.cnblogs.com/xujiating/p/6337511.html" target="_blank" rel="noopener">此处学习</a></p><h3 id="图形化工具下载"><a href="#图形化工具下载" class="headerlink" title="图形化工具下载"></a>图形化工具下载</h3><p><a href="https://www.jetbrains.com/zh/datagrip/promo/?utm_source=baidu&amp;utm_medium=cpc&amp;utm_campaign=cn-bai-br-datagrip-ex-pc&amp;utm_content=datagrip-pure&amp;utm_term=datagrip" target="_blank" rel="noopener">DataGrip下载</a><br>假如你有多个数据库，比如电脑上既有MySQL，又有orcale，那么建议使用DataGrip，其拥有强大的索引及支持多库连接的功能！</p><h4 id="图形化工具安装教程"><a href="#图形化工具安装教程" class="headerlink" title="图形化工具安装教程"></a>图形化工具安装教程</h4><p><a href="https://jingyan.baidu.com/article/86112f13b2a9ee273797871a.html" target="_blank" rel="noopener">百度教程</a></p><h4 id="Datagrip连接数据库"><a href="#Datagrip连接数据库" class="headerlink" title="Datagrip连接数据库"></a>Datagrip连接数据库</h4><p>File -&gt; new -&gt;project -&gt;起一个项目名-&gt;database-&gt;+ -&gt;data source -&gt;创建你需要的数据库</p><h5 id="orcale连接"><a href="#orcale连接" class="headerlink" title="orcale连接"></a>orcale连接</h5><p><img src="http://img.ahdy.top/2019-09-12_100940.png" alt></p><p>如果test测试不成功可以切换Driver进行尝试，并确保orcale的基本服务都已经启动  </p><p>默认的SID是orcl一般都不会对它进行修改，你修改了它并且忘记了Sid可以从<a href="https://jingyan.baidu.com/article/f25ef2549a7e58482c1b82f7.html" target="_blank" rel="noopener">查看sid方法</a>知道你的SID。  </p><p> —在默认情况下，SID的名称和数据库的名称是完全一致的，在网络上使用的是SID名称。</p><h5 id="mysql连接"><a href="#mysql连接" class="headerlink" title="mysql连接"></a>mysql连接</h5><p><img src="http://img.ahdy.top/2019-09-12_101658.png" alt><br>在连接MySQL时可能会出现这种报错<br>解决方法：<br>关联mysql失败_Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezon’<br>时区错误，MySQL默认的时区是UTC时区，比北京时间晚8个小时。</p><p>所以要修改mysql的时长</p><p>在mysql的命令模式下，输入：</p><p>set global time_zone=’+8:00’;<br><img src="http://img.ahdy.top/2019-09-12_101926.png" alt><br>再次进行测试连接，发现连接成功！<br><img src="http://img.ahdy.top/2019-09-12_102039.png" alt><br>成功建立连接后你就可以使用图形化工具对数据库进行增删改查！</p><h3 id="服务禁用"><a href="#服务禁用" class="headerlink" title="服务禁用"></a>服务禁用</h3><p>orcale的后台服务非常拖慢系统运行，建议讲orcale服务修改为手动启动，这样在开机的时候就不会自启。<br>而每次启动的时候，只需要启动两个服务即可：</p><ol><li><p>OracleOraDb11g_home1TNSListener  （监听服务，如果要通过程序或者不同的客户端连接Oracle数据库的时候， 此服务必须启动，否则无法连接。如是自己在本机上操作Oracle，则不需要启动该服务）</p></li><li><p>OracleServiceORCL （数据库的实例服务–保存所有的数据，它的命名标准:OracleServiceSID，每当为系统增加一个数据库的时候，都会出现一个类似的服务名称）</p></li><li><p>查看后台服务的方法，打开控制面板。找到管理工具-&gt;服务<br><img src="http://img.ahdy.top/2019-09-12_103831.png" alt><br><img src="http://img.ahdy.top/2019-09-12_103859.png" alt></p><h3 id="orcale安装失败"><a href="#orcale安装失败" class="headerlink" title="orcale安装失败"></a>orcale安装失败</h3><p>安装失败可能是中断了安装程序，或者装了多个orcale<br>需要卸载干净之后重装。<br>注: 卸载之后可能无法立刻安装成功</p><p> 1.Oracle正常安装完成</p><pre><code>     -- 使用Oracle提供的卸载程序     -- 重新启动电脑，进入到安全模式(启动时按住F8)     -- 找到系统上的对应的磁盘路径，并且删除     -- 运行注册表命令 regedit.exe，搜索所有与oracle有关的内容，并且删除     -- 程序启动电脑后就可以重新执行安装</code></pre><p> 2.Oracle安装失败</p><pre><code>     -- 重新启动电脑，进入到安全模式(启动时按住F8)     -- 找到系统上的对应的磁盘路径，并且删除     -- 运行注册表命令 regedit.exe，搜索所有与oracle有关的内容，并且删除     -- 程序启动电脑后就可以重新执行安装</code></pre></li></ol><p>如果以上操作不行，就需要重新安装操作系统了。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境 </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP</title>
      <link href="/2019/09/04/web/heml7/"/>
      <url>/2019/09/04/web/heml7/</url>
      
        <content type="html"><![CDATA[<h3 id="JSP发展史"><a href="#JSP发展史" class="headerlink" title="JSP发展史"></a>JSP发展史</h3><p>早年说到JAVA Web，那么最具体现力的就是 JSP，但随着时间的发展，原生JSP渐渐淡出了舞台，因为其前后端代码的结合，即是它的优点，又是它的缺点，在团队模块开发上，造成了很大困难，影响团队协作能力，取而代之的是ajax，Ajax的出现使前后端人员可以分工协作，前端不再会为JSP当中的Java代码而苦恼，也很大程度上提高了开发效率。</p><h3 id="JSP格式"><a href="#JSP格式" class="headerlink" title="JSP格式"></a>JSP格式</h3><p><img src="http://img.ahdy.top/2019-09-04_153117.png" alt><br>如你所见，JSP的格式非常像一个HTML网页，那么它的特点在？<br>她最大的特点就是能嵌入Java代码，实现很多由Java代码组合的功能</p><pre><code>&lt;% 代码片段 %&gt; 在括号内写入Java代码  &lt;%! declaration; [ declaration; ]+ ... %&gt; 声明&lt;%= 表达式 %&gt;&lt;%-- 该部分注释在网页中不会被显示--%&gt; &lt;%@ directive attribute=&quot;value&quot; %&gt; 指令</code></pre>]]></content>
      
      
      <categories>
          
          <category> JSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络传输协议</title>
      <link href="/2019/09/03/web/html6/"/>
      <url>/2019/09/03/web/html6/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。</p><p>Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。  </p><p>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。  </p><p>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><h4 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h4><p>HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p><p>一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。</p><p>一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。</p><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><p>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><h4 id="常见异常状态码"><a href="#常见异常状态码" class="headerlink" title="常见异常状态码"></a>常见异常状态码</h4><pre><code>200 - 请求成功301 - 资源（网页等）被永久转移到其它URL404 - 请求的资源（网页等）不存在500 - 内部服务器错误</code></pre><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p>TCP/IP 是因特网的通信协议。</p><p>TCP/IP 通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。</p><h4 id="什么是-TCP-IP？"><a href="#什么是-TCP-IP？" class="headerlink" title="什么是 TCP/IP？"></a>什么是 TCP/IP？</h4><p>TCP/IP 是供已连接因特网的计算机进行通信的通信协议。</p><p>TCP/IP 指传输控制协议/网际协议（Transmission Control Protocol / Internet Protocol）。</p><p>TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。</p><h4 id="内部协议"><a href="#内部协议" class="headerlink" title="内部协议"></a>内部协议</h4><p>在 TCP/IP 中包含一系列用于处理数据通信的协议：</p><p>TCP (传输控制协议) - 应用程序之间通信  </p><p>UDP (用户数据报协议) - 应用程序之间的简单通信  </p><p>IP (网际协议) - 计算机之间的通信<br>IP 是无连接的，用于计算机之间的通信。</p><p>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。</p><p>通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。</p><p>IP 负责将每个包路由至它的目的地。  </p><p>ICMP (因特网消息控制协议) - 针对错误和状态  </p><p>DHCP (动态主机配置协议) - 针对动态寻址</p><h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h4><p>TCP/IP 使用 32 个比特或者 4 组 0 到 255 之间的数字来为计算机编址。</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>每个计算机必须有一个 IP 地址才能够连入因特网。</p><p>每个 IP 包必须有一个地址才能够发送到另一台计算机。</p><p>在本教程下一节，您会学习到更多关于 IP 地址和 IP 名称的知识。<br>TCP/IP 使用 4 组数字来为计算机编址。每个计算机必须有一个唯一的 4 组数字的地址。</p><p>每组数字必须在 0 到 255 之间，并由点号隔开，比如：192.168.1.60。<br>TCP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。</p><p>一个计算机字节可以包含 256 个不同的值：</p><p>00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ……. 直到 11111111。</p><p>现在，您应该知道了为什么 TCP/IP 地址是介于 0 到 255 之间的 4 组数字。</p><h4 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h4><p>Pv6 是 “Internet Protocol Version 6” 的缩写，也被称作下一代互联网协议，它是由 IETF 小组（Internet 工程任务组Internet Engineering Task Force）设计的用来替代现行的 IPv4（现行的）协议的一种新的 IP 协议。</p><p>我们知道，Internet 的主机都有一个唯一的 IP 地址，IP 地址用一个 32 位二进制的数表示一个主机号码，但 32 位地址资源有限，已经不能满足用户的需求了，因此 Internet 研究组织发布新的主机标识方法，即 IPv6。</p><p>在 RFC1884 中（RFC 是 Request for Comments document 的缩写。RFC 实际上就是 Internet 有关服务的一些标准），规定的标准语法建议把 IPv6 地址的 128 位（16 个字节）写成 8 个 16 位的无符号整数，每个整数用 4 个十六进制位表示，这些数之间用冒号（:）分开，例如：</p><p>686E：8C64：FFFF：FFFF：0：1180：96A：FFFF</p><h3 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h3><pre><code>TCP/IP 协议TCP/IP 是不同的通信协议的大集合。协议族TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合。TCP - 传输控制协议TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。IP - 网际协议（Internet Protocol）IP 负责计算机之间的通信。IP 负责在因特网上发送和接收数据包。HTTP - 超文本传输协议(Hyper Text Transfer Protocol)HTTP 负责 web 服务器与 web 浏览器之间的通信。HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。HTTPS - 安全的 HTTP（HTTP Secure）HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。SSL - 安全套接字层（Secure Sockets Layer）SSL 协议用于为安全数据传输加密数据。SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）SMTP 用于电子邮件的传输。MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。IMAP - 因特网消息访问协议（Internet Message Access Protocol）IMAP 用于存储和取回电子邮件。POP - 邮局协议（Post Office Protocol）POP 用于从电子邮件服务器向个人电脑下载电子邮件。FTP - 文件传输协议（File Transfer Protocol）FTP 负责计算机之间的文件传输。NTP - 网络时间协议（Network Time Protocol）NTP 用于在计算机之间同步时间（钟）。DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）DHCP 用于向网络中的计算机分配动态 IP 地址。SNMP - 简单网络管理协议（Simple Network Management Protocol）SNMP 用于计算机网络的管理。LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。ICMP - 因特网消息控制协议（Internet Control Message Protocol）ICMP 负责网络中的错误处理。ARP - 地址解析协议（Address Resolution Protocol）ARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。RARP - 反向地址转换协议（Reverse Address Resolution Protocol）RARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。BOOTP - 自举协议（Boot Protocol）BOOTP 用于从网络启动计算机。PPTP - 点对点隧道协议（Point to Point Tunneling Protocol）PPTP 用于私人网络之间的连接（隧道）。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络传输 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery的使用</title>
      <link href="/2019/09/02/web/html5/"/>
      <url>/2019/09/02/web/html5/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是jQuery？"><a href="#什么是jQuery？" class="headerlink" title="什么是jQuery？"></a>什么是jQuery？</h3><p>jQuery是一个JavaScript函数库。</p><p>jQuery是一个轻量级的”写的少，做的多”的JavaScript库。</p><p>jQuery库包含以下功能：</p><p>HTML 元素选取<br>HTML 元素操作<br>CSS 操作<br>HTML 事件函数<br>JavaScript 特效和动画<br>HTML DOM 遍历和修改<br>AJAX<br>Utilities<br>提示： 除此之外，Jquery还提供了大量的插件。<br>目前网络上有大量开源的 JS 框架, 但是 jQuery 是目前最流行的 JS 框架，而且提供了大量的扩展。</p><p>很多大公司都在使用 jQuery</p><h3 id="jQuery安装"><a href="#jQuery安装" class="headerlink" title="jQuery安装"></a>jQuery安装</h3><p><a href="https://jquery.com/download/" target="_blank" rel="noopener">jQuery官网</a><br>下载比较特殊，你可以选择第一个精简版的下载，不要左键点击（会出现一堆乱码），右键选择将连接另存为到本地就可以下载下来了！下载到本地之后，将js文件引入到web项目当中就可以使用jQuery了！<br>当然也可以不下载官网的jQuery文件，使用URL的方式对jQuery进行响应式加载，例如：使用 Staticfile CDN、百度、又拍云、新浪、谷歌或微软的 jQuery，有一个很大的优势：<br>许多用户在访问其他站点时，已经从百度、又拍云、新浪、谷歌或微软加载过 jQuery。所以结果是，当他们访问您的站点时，会从缓存中加载 jQuery，这样可以减少加载时间。同时，大多数 CDN 都可以确保当用户向其请求文件时，会从离用户最近的服务器上返回响应，这样也可以提高加载速度。</p><h3 id="jQuery引入"><a href="#jQuery引入" class="headerlink" title="jQuery引入"></a>jQuery引入</h3>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS进阶</title>
      <link href="/2019/09/02/web/html4/"/>
      <url>/2019/09/02/web/html4/</url>
      
        <content type="html"><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h4><p>正则表达式是由一个字符序列形成的搜索模式。</p><p>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。</p><p>正则表达式可以是一个简单的字符，或一个更复杂的模式。</p><p>正则表达式可用于所有文本搜索和文本替换的操作。  </p><pre><code>使用正则表达式搜索 &quot;Runoob&quot; 字符串，且不区分大小写：&lt;script type=&quot;text/javascript&quot;&gt;    var string =&quot;helloword!&quot;;    var i=string.search(&#39;h&#39;);    document.getElementById(&quot;1&quot;).innerHTML=i;&lt;/script&gt;/*是否带有小数*/  function    isDecimal(strValue )  {     var  objRegExp= /^\d+\.\d+$/;   return  objRegExp.test(strValue);  }  /*校验是否中文名称组成 */  function ischina(str) {    var reg=/^[\u4E00-\u9FA5]{2,4}$/;   /*定义验证表达式*/    return reg.test(str);     /*进行验证*/}/*校验是否全由8位数字组成 */  function isStudentNo(str) {    var reg=/^[0-9]{8}$/;   /*定义验证表达式*/    return reg.test(str);     /*进行验证*/}/*校验电话码格式 */  function isTelCode(str) {    var reg= /^((0\d{2,3}-\d{7,8})|(1[3584]\d{9}))$/;    return reg.test(str);}/*校验邮件地址是否合法 */  function IsEmail(str) {    var reg=/^\w+@[a-zA-Z0-9]{2,10}(?:\.[a-z]{2,4}){1,3}$/;    return reg.test(str);}</code></pre><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><pre><code>        对于后台开发人员来说，很重要的一个标签。        form 是一个表单，用于存放用户需要提交到后台进行处理的一些数据。        用户填写完后，提交到指定的action1. 检查输入内容是否为空&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;My frist javascript&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        input{            padding: auto;            margin-top: 250px;            background-color: chartreuse;            text-align: center;            border: blue;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;myfram&quot; action=&quot;&quot; onsubmit=&quot;return test()&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;sum&quot; &gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function test () {       var x=document.forms[&quot;myfram&quot;][&quot;sum&quot;].value;        if (x==null || x==&quot;&quot;)        {            alert(&#39;请输入内容&#39;);            return false;        }        else {            alert(&#39;输入内容合法&#39;);            return true;        }    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2. 检查输入内容是否是一个Email地址&lt;script&gt;function validateForm(){    var x=document.forms[&quot;myForm&quot;][&quot;email&quot;].value;    var atpos=x.indexOf(&quot;@&quot;);    var dotpos=x.lastIndexOf(&quot;.&quot;);    if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length){        alert(&quot;不是一个有效的 e-mail 地址&quot;);          return false;    }}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;myForm&quot; action=&quot;demo-form.php&quot; onsubmit=&quot;return validateForm();&quot; method=&quot;post&quot;&gt;Email: &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="标签元素值获取"><a href="#标签元素值获取" class="headerlink" title="标签元素值获取"></a>标签元素值获取</h3><pre><code>1. 通过id获取2. 通过标签名获取3. 通过类名获取&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;My frist javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;88&quot;&gt;    &lt;p id=&quot;5&quot;&gt;&lt;/p&gt;    &lt;p id=&quot;8848&quot; class=&quot;c3p0&quot;&gt;今天是星期五！&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--  通过id获取元素值--&gt;var z=document.getElementById(&quot;8848&quot;).innerHTMLdocument.write(z)&lt;!--通过标签名获取元素值--&gt;    var x = document.getElementById(&quot;88&quot;);    var y = x.getElementsByTagName(&quot;p&quot;);    document.write(y[1].innerHTML);&lt;!--  通过类名获取元素的值--&gt;    var b=document.getElementsByClassName(&quot;c3p0&quot;);    //元素标签下标的使用其实是根据某一块级标签下相同元素个数使用的    //比如在一个div标签当中有多个p标签，那么当byclass获取到div值的时候就可以用下标的方式来显示你想输出第几个标签的内容    document.write(b[0].innerHTML);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="修图片的地址"><a href="#修图片的地址" class="headerlink" title="修图片的地址"></a>修图片的地址</h3><pre><code>&lt;img id=&quot;image&quot; src=&quot;smiley.gif&quot;&gt;&lt;script&gt;document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;&lt;/script&gt;</code></pre><h3 id="API验证输入"><a href="#API验证输入" class="headerlink" title="API验证输入"></a>API验证输入</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;请输入100~300之间的数据进行api验证！&lt;/p&gt;&lt;input type=&quot;number&quot; min=&quot;100&quot; max=&quot;300&quot; id=&quot;test&quot; required&gt;&lt;button onclick=&quot;f()&quot;&gt;验证&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function f() {        var x=document.getElementById(&quot;test&quot;);        if(x.checkValidity()==false)        {            document.getElementById(&quot;demo&quot;).innerHTML=x.validationMessage;        }        else        {            document.getElementById(&quot;demo&quot;).innerHTML=&quot;输入正确&quot;;        }    }&lt;/script&gt;/*&lt;script&gt;function myFunction() {var txt = &quot;&quot;;if (document.getElementById(&quot;id1&quot;).validity.rangeOverflow) {    txt = &quot;输入的值太大了&quot;;} else {    txt = &quot;输入正确&quot;;}document.getElementById(&quot;demo&quot;).innerHTML = txt;}&lt;/script&gt;&lt;script&gt;function myFunction() {var txt = &quot;&quot;;var inpObj = document.getElementById(&quot;id1&quot;);if(!isNumeric(inpObj.value)) {    txt = &quot;你输入的不是数字&quot;;} else if (inpObj.validity.rangeUnderflow) {    txt = &quot;输入的值太小了&quot;;} else {    txt = &quot;输入正确&quot;;}document.getElementById(&quot;demo&quot;).innerHTML = txt;}// 判断输入是否为数字function isNumeric(n) {return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);}&lt;/script&gt;*/&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>JavaScript this 关键字<br>面向对象语言中 this 表示当前对象的一个引用。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON 英文全称 JavaScript Object Notation<br>JSON 是一种轻量级的数据交换格式。<br>JSON是独立的语言 *<br>JSON 易于理解。  </p><pre><code>1. json数据转换为js对象&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;为 JSON 字符串创建对象&lt;/h2&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var text = &#39;{ &quot;sites&quot; : [&#39; +    &#39;{ &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; },&#39; +    &#39;{ &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; },&#39; +    &#39;{ &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; } ]}&#39;;obj = JSON.parse(text);document.getElementById(&quot;demo&quot;).innerHTML = obj.sites[1].name + &quot; &quot; + obj.sites[1].url;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>javascript:void(0) 中最关键的是 void 关键字， void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值。<br>href=”#”与href=”javascript:void(0)”的区别</p><pre><code># 包含了一个位置信息，默认的锚是#top 也就是网页的上端。</code></pre><p>而javascript:void(0), 仅仅表示一个死链接。</p><p>在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id。</p><p>如果你要定义一个死链接请使用 javascript:void(0)</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在JS当中，函数存在构造函数，递归，函数是一个对象，也可以作为值来传递</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><pre><code>先看一个简单的时间显示，该方法能显示出当前系统时间&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在页面显示一个时钟&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var myVar=setInterval(function(){myTimer()},1000);function myTimer(){    var d=new Date();    var t=d.toLocaleTimeString();    document.getElementById(&quot;demo&quot;).innerHTML=t;}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>Cookie 是一些数据, 存储于你电脑上的文本文件中。</p><p>当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。</p><p>Cookie 的作用就是用于解决 “如何记录客户端的用户信息”:</p><p>当用户访问 web 页面时，他的名字可以记录在 cookie 中。<br>在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。<br>使用js可以对本地的cookie进行修改，也可以将一些数据写入到本地cookie当中！<br>JavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie</p><h3 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;f()&quot;&gt;确定&lt;/button&gt;&lt;!--加载式弹窗--&gt;&lt;script type=&quot;text/javascript&quot;&gt;    window.alert(&#39;你好&#39;);&lt;/script&gt;&lt;!--事件式弹窗--&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function f() {        var x= confirm(&quot;按下了按钮&quot;);//confirf函数中返回的是true/false值        if (x=true)        {            x=&quot;你按下了确定按钮&quot;;        }        else        {            x=&quot;你按的不是确定按钮&quot;;        }        document.getElementById(&quot;demo&quot;).innerHTML=x;    }&lt;/script&gt;&lt;!--输入式弹窗--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var y=prompt(); document.write(y)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;  检查当前cookie是否可用&lt;script&gt;function checkCookies(){    if (navigator.cookieEnabled==true){        alert(&quot;Cookies 可用&quot;)    }    else{        alert(&quot;Cookies 不可用&quot;)    }}&lt;/script&gt;</code></pre><h3 id="JS中的页面前进与后退"><a href="#JS中的页面前进与后退" class="headerlink" title="JS中的页面前进与后退"></a>JS中的页面前进与后退</h3><pre><code>实现界面的专挑可以使用a标签，添加指定的跳转页面，当然用JS也是可以进行界面跳转的设置。  window.history函数&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button type=&quot;button&quot; onclick=&quot;f()&quot;&gt;返回&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function f() {        //返回后一个界面        window.history.back();    }    function b() {        //前进上一个界面        window.history.forward();    }&lt;/script&gt;&lt;!--function a(){    history.go(1);  // go() 里面的参数表示跳转页面的个数 例如 history.go(1) 表示前进一个页面}function b(){    history.go(-1);  // go() 里面的参数表示跳转页面的个数 例如 history.go(-1) 表示后退一个页面}--&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="获取当前浏览器URL"><a href="#获取当前浏览器URL" class="headerlink" title="获取当前浏览器URL"></a>获取当前浏览器URL</h3><p>ocation.hostname 返回 web 主机的域名  </p><p>location.pathname 返回当前页面的路径和文件名 </p><p>location.port 返回 web 主机的端口 （80 或 443）</p><p>location.protocol 返回所使用的 web 协议（http: 或 https:）</p><pre><code>返回（当前页面的）整个 URL：&lt;script&gt;document.write(location.href);&lt;/script&gt;返回当前 URL 的路径名：&lt;script&gt;document.write(location.pathname);&lt;/script&gt;重定向一个网页function f1() {    window.location.assign(&quot;http://www.baidu.com&quot;);}</code></pre><h3 id="获取屏幕的高和宽-px"><a href="#获取屏幕的高和宽-px" class="headerlink" title="获取屏幕的高和宽(px)"></a>获取屏幕的高和宽(px)</h3><p>screen.availWidth - 可用的屏幕宽度<br>screen.availHeight - 可用的屏幕高度  </p><pre><code>例：&lt;script&gt;document.write(&quot;可用高度: &quot; + screen.availHeight);&lt;/script&gt;</code></pre><h3 id="字符串查询"><a href="#字符串查询" class="headerlink" title="字符串查询"></a>字符串查询</h3><p>test()<br>test()方法搜索字符串指定的值，根据结果并返回真或假。  </p><p>exec()<br>exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。<br>使用方法：当定义了一个变量var x=”xxxxx”；<br>document.write(x.test(‘参数’))；  </p><h3 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h3><p>round()<br>使用 round()。</p><p>random()<br>使用 random() 来返回 0 到 1 之间的随机数。</p><p>max()<br>如何使用 max() 来返回两个给定的数中的较大的数。（在 ECMASCript v3 之前，该方法只有两个参数。）</p><p>min()<br>如何使用 min() 来返回两个给定的数中的较小的数。（在 ECMASCript v3 之前，该方法只有两个参数。）</p><h3 id="点击事件的创建"><a href="#点击事件的创建" class="headerlink" title="点击事件的创建"></a>点击事件的创建</h3><pre><code>&lt;script&gt;document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, displayDate);function displayDate() {    document.getElementById(&quot;demo&quot;).innerHTML = Date();}&lt;/script&gt;</code></pre><h4 id="文本修改事件"><a href="#文本修改事件" class="headerlink" title="文本修改事件"></a>文本修改事件</h4><pre><code>&lt;h1 onclick=&quot;this.innerHTML=&#39;Ooops!&#39;&quot;&gt;点击文本!&lt;/h1&gt;</code></pre><p>你可以点击下面的文字进行测试！</p><p></p><h1 onclick="this.innerHTML='Ooops!'">点击文本!</h1><p></p><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><pre><code> 1. 函数使用&lt;input 文本框，当时鼠标离开文本框时，事件触发，    该函数的作用是将大小写进行转换&lt;script&gt;function myFunction(){    var x=document.getElementById(&quot;fname&quot;);    x.value=x.value.toUpperCase();}&lt;/script&gt;2. div onmouseover=&quot;mOver(this)&quot; onmouseout=&quot;mOut(this)&quot; style=&quot;background-color:#D94A38;width:120px;height:20px;padding:40px;&quot;&gt;Mouse Over Me&lt;/div&gt;&lt;script&gt;function mOver(obj){    obj.innerHTML=&quot;Thank You&quot;}function mOut(obj){    obj.innerHTML=&quot;Mouse Over Me&quot;}&lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="样式的改变"><a href="#样式的改变" class="headerlink" title="样式的改变"></a>样式的改变</h3><pre><code>改变 HTML 样式如需改变 HTML 元素的样式，请使用这个语法：document.getElementById(id).style.property=新样式</code></pre><h3 id="JS实例"><a href="#JS实例" class="headerlink" title="JS实例"></a>JS实例</h3><p><a href="https://www.runoob.com/js/js-examples.html" target="_blank" rel="noopener">菜鸟</a></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS快速入门</title>
      <link href="/2019/08/28/web/html3/"/>
      <url>/2019/08/28/web/html3/</url>
      
        <content type="html"><![CDATA[<h3 id="JS变量"><a href="#JS变量" class="headerlink" title="JS变量"></a>JS变量</h3><pre><code>在js当中没有特殊的数据类型声明方式，所有类型的数据都以var命名  例如：var a = 0；  js基础与Java语法类似</code></pre><h3 id="弹窗-输出"><a href="#弹窗-输出" class="headerlink" title="弹窗/输出"></a>弹窗/输出</h3><pre><code>1. 简单的弹窗 （1）&lt;script type=&quot;text/javascript&quot;&gt;    alert(&#39;hello word！&#39;);&lt;/script&gt; （2）&lt;script type=&quot;text/javascript&quot;&gt;    window.alert(&#39;hello word！&#39;);&lt;/script&gt;2. 向HTML元素中写入 &lt;script type=&quot;text/javascript&quot;&gt;  document.write(&quot;今天是个好日子！&quot;);&lt;/script&gt;3. 打印到控制台 &lt;script type=&quot;text/javascript&quot;&gt;  console.log(&#39;你好陌生人！&#39;);&lt;/script&gt;</code></pre><h3 id="修改标签元素"><a href="#修改标签元素" class="headerlink" title="修改标签元素"></a>修改标签元素</h3><p><img src="http://img.ahdy.top/2019-08-29_100217.png" alt><br><img src="http://img.ahdy.top/2019-08-29_100300.png" alt></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><pre><code>(1)var length = 16;                                  // Number 通过数字字面量赋值 var points = x * 10;                              // Number 通过表达式字面量赋值var lastName = &quot;Johnson&quot;;                         // String 通过字符串字面量赋值var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];              // Array  通过数组字面量赋值var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;};  // Object 通过对象字面量赋值(2)值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。引用数据类型：对象(Object)、数组(Array)、函数(Function)。</code></pre><h4 id="Aarray数组"><a href="#Aarray数组" class="headerlink" title="Aarray数组"></a>Aarray数组</h4><pre><code>var sum =new Array();</code></pre><h4 id="JS字符串"><a href="#JS字符串" class="headerlink" title="JS字符串"></a>JS字符串</h4><p>关于字符串的定义可以使用单引号或者双引号；  </p><pre><code>一般形式为：  var carname=&quot;Volvo XC60&quot;;var carname=&#39;Volvo XC60&#39;;代码        输出\&#39;        单引号\&quot;        双引号\\        反斜杠\n        换行\r        回车\t        tab(制表符)\b        退格符\f        换页符</code></pre><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><pre><code>var y = new String(&quot;John&quot;);</code></pre><h4 id="JS函数"><a href="#JS函数" class="headerlink" title="JS函数"></a>JS函数</h4><pre><code>function myFunction(a, b) {return a * b;                                // 返回 a 乘以 b 的结果}</code></pre><h3 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h3><pre><code>break    用于跳出循环。catch    语句块，在 try 语句块执行出错时执行 catch 语句块。continue    跳过循环中的一个迭代。do ... while    执行一个语句块，在条件语句为 true 时继续执行该语句块。for    在条件语句为 true 时，可以将代码块执行指定的次数。for ... in    用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。function    定义一个函数if ... else    用于基于不同的条件来执行不同的动作。return    退出函数switch    用于基于不同的条件来执行不同的动作。throw    抛出（生成）错误 。try        实现错误处理，与 catch 一同使用。var        声明一个变量。while    当条件语句为 true 时，执行语句块。</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>JS当中的注释与Java注释一致<br>    1.单行注释<br>//<br>    2.<br>多行注释以<code>/* 开始，以 */ 结尾。</code>    </p><h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><pre><code>var person = {firstName:&quot;John&quot;,lastName:&quot;Doe&quot;,age:50,eyeColor:&quot;blue&quot;};</code></pre><p>对象属性的定义它可以是对某一事物的描述，有点像java里面的泛型..</p><h3 id="JS函数的调用"><a href="#JS函数的调用" class="headerlink" title="JS函数的调用"></a>JS函数的调用</h3><pre><code>(弹窗函数的调用)&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;My frist javascript&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;  function f() {      window.alert(&#39;按钮弹窗测试！&#39;)  }&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick=&quot;f()&quot; &gt;点我&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;(带参函数的调用,document不能写在标签元素之前，不然控制台会报错，《innerhtml 值为空！》)&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;My frist javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;function f(a,b) {    return a*b;}document.getElementById(&quot;1&quot;).innerHTML=f(4,3);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><p>js当中的函数同Java一样，也分为全局/局部变量</p><h3 id="JS事件"><a href="#JS事件" class="headerlink" title="JS事件"></a>JS事件</h3><pre><code>onchange    HTML 元素改变onclick    用户点击 HTML 元素onmouseover    用户在一个HTML元素上移动鼠标onmouseout    用户从一个HTML元素上移开鼠标onkeydown    用户按下键盘按键onload    浏览器已完成页面的加载</code></pre><p>例子：<br><img src="http://img.ahdy.top/2019-08-29_110209.png" alt></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符基本与Java一致，JS当中也支持三元运算符<br><code>voteable=(age&lt;18)?&quot;年龄太小&quot;:&quot;年龄已达到&quot;;</code></p><h3 id="检查数据类型"><a href="#检查数据类型" class="headerlink" title="检查数据类型"></a>检查数据类型</h3><p>你可以使用 typeof关键字来查看一个数据的数据类型  </p><pre><code>例如：typeof &quot;John&quot;                // 返回 string typeof 3.14                  // 返回 numbertypeof false                 // 返回 booleantypeof [1,2,3,4]             // 返回 objecttypeof {name:&#39;John&#39;, age:34} // 返回 object</code></pre><h3 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h3><pre><code>在 JavaScript 中有 5 种不同的数据类型：stringnumberbooleanobjectfunction3 种对象类型：ObjectDateArray2 个不包含任何值的数据类型：nullundefined</code></pre><p>例：<br>String(a);<br>Number(b);</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>对于JS代码调试，组好的方法就是使用chrome +F12<br>或者使用断点+console.log(打印输出)；</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易音乐外链获取</title>
      <link href="/2019/08/23/link/"/>
      <url>/2019/08/23/link/</url>
      
        <content type="html"><![CDATA[<h3 id="外链简述"><a href="#外链简述" class="headerlink" title="外链简述"></a>外链简述</h3><pre><code>以下内容来源于百度百科</code></pre><p>外链就是指在别的网站导入自己网站的链接。导入链接对于网站优化来说是非常重要的一个过程。导入链接的质量（即导入链接所在页面的权重）间接影响了我们的网站在搜索引擎中的权重。<br>外链是互联网的血液，是链接的一种。没有链接的话，信息就是孤立的，结果就是我们什么都看不到。一个网站是很难做到面面俱到的，因此需要链接到别的网站，将其他网站所能补充的信息吸收过来，连接外链不在于数量，而是在于链接外链的质量。<br>外链的效果不只是为了提高网站的权重，也不仅仅是为了提高某个关键词的排名。一个高质量的外部链接是可以给网站带来很好的流量。</p><h3 id="获取网易云音乐外链"><a href="#获取网易云音乐外链" class="headerlink" title="获取网易云音乐外链"></a>获取网易云音乐外链</h3><p>假如你需要开发一个有特色的网站，那么避免不了外链元素的加入，这些外链，可以是图片超链接，可以是域名，或是各大知名网站的Url，正是这些外链，体现了万物互联的姿态。  </p><pre><code>当你的网页上有一个音乐播放模块，你想加入你喜欢的音乐，这该怎么办呢？  </code></pre><ol><li>打开百度搜索引擎，搜索网易云音乐</li><li>这时候点击一首歌，生成外链播放器，会发现由于版权问题不能生成音乐播放器的外链。<br><img src="http://img.ahdy.top/2019-08-23_200547.png" alt>  </li><li>这时候请注意浏览器URL地址栏，将浏览器内的id=？？后的数字记下，替换掉下面给出的URL地址中id的值，此时下面的音乐URL就变成了你想播放音乐的外链！<br><img src="http://img.ahdy.top/2019-08-23_201113.png" alt><br> <code>http://music.163.com/song/media/outer/url?id=将数值替换掉此处中文.mp3</code>  </li><li>测试外链<br><img src="http://img.ahdy.top/2019-08-23_202852.png" alt><br>5.外链成功播放音乐~<br><img src="http://img.ahdy.top/2019-08-23_202943.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> Url </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Url </tag>
            
            <tag> 外链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS快速入门</title>
      <link href="/2019/08/22/web/html2/"/>
      <url>/2019/08/22/web/html2/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h3><pre><code>        CSS 指层叠样式表(Cascading Style sheets)        定义样式如何显示HTML。更好的渲染html页面，让它看上去更加的绚丽多彩。        有3种展示展示方式：        1.外部样式            定义在以.css为后缀的文件当中，然后在.html为后缀的文件中引入。            方便维护。提高工作效率        2.内部样式            写在html文件中的head标记中。        3.内联样式            写在html标签中。        通常css样式可以写在.css文件当中，也可以在HTML文件当中，使用&lt;style&gt;标签来声明。</code></pre><h3 id="HTML样式嵌入"><a href="#HTML样式嵌入" class="headerlink" title="HTML样式嵌入"></a>HTML样式嵌入</h3><p>如图，是js以及css样式内部写法，当然也可以将其放在.js/.cs文件夹内，通过link/script标签将其引入，这种写法就达到了一种封装设计理念!<br><img src="http://img.ahdy.top/2019-08-23_084436.png" alt></p><h3 id="CSS常用标签"><a href="#CSS常用标签" class="headerlink" title="CSS常用标签"></a>CSS常用标签</h3><h4 id="display-visibility"><a href="#display-visibility" class="headerlink" title="display/visibility"></a>display/visibility</h4><p><img src="http://img.ahdy.top/2019-08-23_085658.png" alt><br>可能效果不是太明显，大概意思就是，&lt;span 标签经过css样式修饰后有了和&lt;p 标签一样的属性，注*span标签是没有任何属性的一个标签，通常被用来提示，脚注等<br><img src="http://img.ahdy.top/2019-08-23_090419.png" alt>  </p><p><img src="http://img.ahdy.top/2019-08-23_091422.png" alt></p><h4 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h4><p>可以通过两种方式来设置背景颜色，背景颜色可以被细分为全局颜色，和局部颜色<br><img src="http://img.ahdy.top/2019-08-23_092502.png" alt><br><img src="http://img.ahdy.top/2019-08-23_092520.png" alt="效果图"></p><h4 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h4><p>假如你有一个喜欢的图片想将它作为背景图片,可以通过这种方式<br><img src="http://img.ahdy.top/2019-08-23_094235.png" alt><br>其大小根据百分比设定，直接使用了&lt;body标签命名样式所以不再需要样式引入！  </p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p><img src="http://img.ahdy.top/2019-08-23_101443.png" alt><br><img src="http://img.ahdy.top/2019-08-23_101508.png" alt="样式展示"></p><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p><img src="http://img.ahdy.top/2019-08-23_100037.png" alt><br><img src="http://img.ahdy.top/2019-08-23_100147.png" alt="效果展示"><br><img src="http://img.ahdy.top/2019-08-23_100626.png" alt><br><img src="http://img.ahdy.top/2019-08-23_100711.png" alt="效果展示"></p><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><p><img src="http://img.ahdy.top/2019-08-23_101036.png" alt><br><img src="http://img.ahdy.top/2019-08-23_101049.png" alt="样式展示"></p><h4 id="滚动框"><a href="#滚动框" class="headerlink" title="滚动框"></a>滚动框</h4><p><img src="http://img.ahdy.top/2019-08-23_102356.png" alt><br><img src="http://img.ahdy.top/2019-08-23_102604.png" alt="效果展示"></p><h4 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h4><p><img src="http://img.ahdy.top/2019-08-23_102855.png" alt></p><h4 id="超链接样式"><a href="#超链接样式" class="headerlink" title="超链接样式"></a>超链接样式</h4><p><img src="http://img.ahdy.top/2019-08-23_103428.png" alt></p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p><img src="http://img.ahdy.top/2019-08-23_103601.png" alt="盒模型"><br>这个概念主要应用在padding/margin上，padding意为间距，其排版为顺时针，也就是上左下又，经常可见padding参数中有四个px参数，margin也是如此，区别是margin是外边距，padding是内边距，&lt;div标签可以形象展示，通俗点说，padding是盒子内部的间距，margin是盒子相对于其他元素间的间距。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML快速入门</title>
      <link href="/2019/08/21/web/html/"/>
      <url>/2019/08/21/web/html/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是HTML5语言"><a href="#什么是HTML5语言" class="headerlink" title="什么是HTML5语言"></a>什么是HTML5语言</h3><pre><code>    HTML是一种标记语言，用于网络渲染界面呈现具体图形，网络流，文字等信息给用户查阅的一种    浏览器解释运行的弱语言。    HTML文件必须以.html或者.htm为后缀。但是.htm是很多年以前过时的写法，一些浏览器也兼容    但是不建议使用.htm的后缀</code></pre><h3 id="什么是CSS3"><a href="#什么是CSS3" class="headerlink" title="什么是CSS3"></a>什么是CSS3</h3><pre><code>    用于渲染页面的色彩、样式等规则。总结：用于美化页面    老师形象的把css样式比喻成女生的化妆品。</code></pre><h3 id="什么是JS-JavaScript"><a href="#什么是JS-JavaScript" class="headerlink" title="什么是JS(JavaScript)"></a>什么是JS(JavaScript)</h3><pre><code>    可以动态渲染页面的一种弱类型语言。    是页面的行为。    HTML5 + CSS3 是静态页面，不能与用户进行交互。    而使用JS后，可以与用户进行交互。</code></pre><h3 id="HTML文本标签"><a href="#HTML文本标签" class="headerlink" title="HTML文本标签"></a>HTML文本标签</h3><p><img src="http://img.ahdy.top/2019-08-20_154347.png" alt></p><h3 id="HTML超链接"><a href="#HTML超链接" class="headerlink" title="HTML超链接"></a>HTML超链接</h3><p><img src="http://img.ahdy.top/2019-08-20_160811.png" alt></p><h3 id="HTML列表"><a href="#HTML列表" class="headerlink" title="HTML列表"></a>HTML列表</h3><p><img src="http://img.ahdy.top/2019-08-20_173123.png" alt></p><h3 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h3><p><img src="http://img.ahdy.top/2019-08-20_173908.png" alt></p><h3 id="HTML页面框架"><a href="#HTML页面框架" class="headerlink" title="HTML页面框架"></a>HTML页面框架</h3><p>你需要创建几个HTML页面，并在frameset标签下引入，标签的头部可以使用比例进行排版<br>注意该标签不能放在&lt;body 标签下使用<br><img src="http://img.ahdy.top/2019-08-20_175443.png" alt></p><h3 id="常用权重标签"><a href="#常用权重标签" class="headerlink" title="常用权重标签"></a>常用权重标签</h3><h4 id="div"><a href="#div" class="headerlink" title="div"></a>div</h4><p><img src="http://img.ahdy.top/2019-08-20_182454.png" alt></p><h4 id="form"><a href="#form" class="headerlink" title="form"></a>form</h4><p><img src="http://img.ahdy.top/2019-08-20_182559.png" alt></p><h4 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h4><p>外边框<br><img src="http://img.ahdy.top/2019-08-20_182804.png" alt></p><h4 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h4><p>横向排版超链接<br><img src="http://img.ahdy.top/2019-08-21_111503.png" alt></p><h4 id="下拉选项"><a href="#下拉选项" class="headerlink" title="下拉选项"></a>下拉选项</h4><p><img src="http://img.ahdy.top/2019-08-21_111557.png" alt></p><h4 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h4><p>加载进度条<br><img src="http://img.ahdy.top/2019-08-21_121831.png" alt></p><h4 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h4><p>文本框<br><img src="http://img.ahdy.top/2019-08-21_171250.png" alt></p><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>极为重要的签，功能强大<br><img src="http://img.ahdy.top/2019-08-21_172002.png" alt><br>效果预览<br><img src="http://img.ahdy.top/2019-08-21_172100.png" alt></p><h4 id="lable"><a href="#lable" class="headerlink" title="lable"></a>lable</h4><p><img src="http://img.ahdy.top/2019-08-21_172325.png" alt></p><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>表格<br><img src="http://img.ahdy.top/2019-08-21_172524.png" alt><br>效果预览<br><img src="http://img.ahdy.top/2019-08-21_172538.png" alt></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>单纯的HTML是否显得过于简陋？，怎样使页面变得美观绚丽？</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ机器人</title>
      <link href="/2019/08/20/robot/"/>
      <url>/2019/08/20/robot/</url>
      
        <content type="html"><![CDATA[<p>你是否见过QQ上的qq小冰呢！你是否也想拥有一个自己的机器人的呢！<br>下面我将告诉你，怎么一行代码都不写就实现一个QQ机器人</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>工具需要，酷Q插件+图灵机器人api</li><li>步骤，百度一下入图灵机器人官网，注册一个账号，这个实名注册一下，一天有100条免费消息，嗯以前是500条就在前不久，官方说机器人资源泛滥，决定调整，它这个意思很明确，咱用免费的就可以了，（实名认证一般一天之内就能认证成功）<br><img src="http://img.ahdy.top/201908201.png" alt></li><li>这时候我相信你已经注册，并且实名认证成功了，接下来就选择创建一个机器人<br><img src="http://img.ahdy.top/2001908202.png" alt></li><li>这些选项可以根据自己的需求去选，它这个语言库可能有区别<br>创建好了之后，百度下载一个叫酷Q的插件（这个插件可以登陆QQ号）<br>登上去你的这个QQ它就变成了机器人<br><img src="http://img.ahdy.top/201908203.png" alt></li><li>登录以后配置它<br><img src="http://img.ahdy.top/201908204.png" alt><br>进入图灵官网找到apikey<br><img src="http://img.ahdy.top/201908205.png" alt></li><li>将你创建好的机器人api密匙复制到下图apykey处选择保存<br><img src="http://img.ahdy.top/201908206.png" alt></li><li>使用QQ对当前机器人发送消息：<br><img src="http://img.ahdy.top/201908207.png" alt><br>8.QQ机器人创建完成！</li></ol>]]></content>
      
      
      <categories>
          
          <category> robot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> 机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花生壳内网穿透</title>
      <link href="/2019/08/15/web/sever/"/>
      <url>/2019/08/15/web/sever/</url>
      
        <content type="html"><![CDATA[<h3 id="花生壳下载"><a href="#花生壳下载" class="headerlink" title="花生壳下载"></a>花生壳下载</h3><p>下载了这个软件你将会获得免费域名，端口映射服务大礼包，听起来是不是很炫酷(虽然这个域名不怎么好，但是我们目的很简单能用就OK！)<a href="https://hsk.oray.com/" target="_blank" rel="noopener">下载地址</a><br>嗯，下载，安装，注册个账号都会吧！不用教了呗！<br>实在不会可以戳这儿<a href="https://blog.csdn.net/niaonao/article/details/91411044" target="_blank" rel="noopener">详细图文教程</a></p><h3 id="花生壳配置"><a href="#花生壳配置" class="headerlink" title="花生壳配置"></a>花生壳配置</h3><p>这个配置非常简单,傻瓜式流程  </p><p><img src="http://img.ahdy.top/2019-08-15_213709.png" alt><br><img src="https://raw.githubusercontent.com/niaonao/ImageIcon/master/IDEAProject/Wechat/Image11.png#pic_center" alt><br>确定完成配置。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>你的电脑是WiFi就选择无限局域网的ip地址，如果是网线就选择以太网内的ip地址！<br><img src="http://img.ahdy.top/2019-08-15_215931.png" alt><br>接下来你就要诊断创建实例的各项指标是否正常，我敢说绝对会不正常，不要问我为啥，因为你电脑没有局域网服务，不服可以来打我。  </p><h3 id="环境诊断"><a href="#环境诊断" class="headerlink" title="环境诊断"></a>环境诊断</h3><p><img src="http://img.ahdy.top/2019-08-15_215041.png" alt>  </p><p><img src="http://img.ahdy.top/2019-08-15_215118.png" alt><br>如果没猜错你会出现跟我一模一样的情况，下面我教你用最简单的方式把web项目托管的环境搭建好！</p><h3 id="服务器搭建"><a href="#服务器搭建" class="headerlink" title="服务器搭建"></a>服务器搭建</h3><p><a href="https://share.weiyun.com/57Wjpp2" target="_blank" rel="noopener">tomcat7</a>请务必把它下载下来，是个压缩包，解压即用，别说你不会解压昂！<br>下载解压好如下<br><img src="http://img.ahdy.top/2019-08-15_220438.png" alt><br>web项目放在下图路径内<br><img src="http://img.ahdy.top/2019-08-15_220553.png" alt><br>进入下图路径修改server.xml<br><img src="http://img.ahdy.top/2019-08-15_220953.png" alt><br>把带有80端口的代码块复制粘贴一份，将80端口改为8080，跟图一样保存退出（至关重要）<br><img src="http://img.ahdy.top/2019-08-15_221155.png" alt><br>回到wbesver文件下选择启动服务<br><img src="http://img.ahdy.top/2019-08-15_220822.png" alt><br>出现黑窗口，显示运行秒数则服务启动成功<br><img src="http://img.ahdy.top/2019-08-15_221702.png" alt><br>中间如果弹出防火墙阻止，请选择服务允许访问<br>我们再来检查诊断一下实例发现所有项都已经配置成功<br><img src="http://img.ahdy.top/2019-08-15_221847.png" alt><br>使用域名，或者你本机的ip地址就可以访问你的web项目了<br>下面是我的测试页面<br><img src="http://img.ahdy.top/2019-08-15_222123.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 花生壳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶</title>
      <link href="/2019/08/12/web/mysql3/"/>
      <url>/2019/08/12/web/mysql3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是JBDC"><a href="#什么是JBDC" class="headerlink" title="什么是JBDC"></a>什么是JBDC</h3><p>1、Java Data BaseConnectivity(Java数据库连接)：是java与数据库的桥梁，提供读写操作</p><p>2、JDBC：用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问。通过JDBC可以连接Oracle、MySql、SqlServer数据库</p><p>3、JDBC：应用服务器和数据库DB之间的数据流通过程，实现应用服务器对数据库的操作。  </p><h3 id="JDBC使用"><a href="#JDBC使用" class="headerlink" title="JDBC使用"></a>JDBC使用</h3><p>（需要导入mysql-connector-java-5.1.7-bin的jar包）</p><p>1.加载驱动程序： Class.forName（driverClass）</p><p>加载Mysql驱动：Class.forName(“com.mysql.jdbc.Driver”)</p><p>加载Oracle驱动：Class.forName(“oracle.jdbc.driver.OracleDriver”)</p><p>***注意：驱动是固定写法  </p><p>2.获得数据库连接:</p><p>DriverManager.getConnection(“jdbc:mysql://127.0.0.1:3306/imooc”,”root”,”root”);</p><p>***注释：其中jdbc:mysql表示jdbc连接mysql，127.0.0.1:3306为服务器地址和端口，imooc为数据库名称，root分别是用户名和密码</p><p>3.创建Statement对象： conn.createStatement();  </p><h3 id="学生管理系统系统（控制台版）"><a href="#学生管理系统系统（控制台版）" class="headerlink" title="学生管理系统系统（控制台版）"></a>学生管理系统系统（控制台版）</h3><p>我写了一个对mysql进行增删查的管理系统，基于控制台<a href="https://pan.baidu.com/s/1zfpzp3Y0GxNbd-_VCkdsag" target="_blank" rel="noopener">百度网盘</a><br><img src="http://img.ahdy.top/2019-08-12_152641.png" alt></p><h5 id="献丑！"><a href="#献丑！" class="headerlink" title="献丑！"></a>献丑！</h5><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>五、代码分析<br>　　在对数据库进行增删改查的过程中，可以发现其共性部分，即通用的流程：</p><p>　　(1)创建Connection对象、SQL查询命令字符串；</p><p>　　(2)对Connection对象传入SQL查询命令，获得PreparedStatement对象；</p><p>　　(3)对PreparedStatement对象执行executeUpdate()或executeQurey()获得结果；</p><p>　　(4)先后关闭PreparedStatement对象和Connection对象。</p><p>　　可见，使用JDBC时，最常打交道的是Connection、PreparedStatement这两个类，以及select中的ResultSet类。查阅Java API手册可以了解其具体的意义和方法。</p><p><code>Connection   java.sql    接口 Connection   所有超级接口：Wrapperpublic interface Connectionextends Wrapper</code></p><p>与特定数据库的连接（会话）。在连接上下文中执行 SQL 语句并返回结果。</p><p>Connection 对象的数据库能够提供描述其表、所支持的 SQL 语法、存储过程、此连接功能等等的信息。此信息是使用 getMetaData 方法获得的。</p><h3 id="PreparedStatemnt"><a href="#PreparedStatemnt" class="headerlink" title="PreparedStatemnt"></a>PreparedStatemnt</h3><p>   java.sql<br>   接口 PreparedStatement<br>   所有超级接口：<br>Statement, Wrapper<br>所有已知子接口：<br>CallableStatement<br>public interface PreparedStatementextends Statement<br>表示预编译的 SQL 语句的对象。</p><p>SQL 语句被预编译并存储在 PreparedStatement 对象中。然后可以使用此对象多次高效地执行该语句。</p><p>常用方法</p><p> boolean  execute()</p><pre><code>      在此 PreparedStatement 对象中执行 SQL 语句，该语句可以是任何种类的 SQL 语句。</code></pre><p> ResultSet  executeQuery()</p><pre><code>      在此 PreparedStatement 对象中执行 SQL 查询，并返回该查询生成的 ResultSet 对象。</code></pre><p> int  executeUpdate()</p><pre><code>  在此 PreparedStatement 对象中执行 SQL 语句，该语句必须是一个 SQL 数据操作语言（Data Manipulation Language，DML）语句，比如 INSERT、UPDATE 或 DELETE 语句；或者是无返回内容的 SQL 语句，比如 DDL 语句。</code></pre><p>　　</p><h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><p>　　</p><p>java.sql </p><h4 id="接口-ResultSet"><a href="#接口-ResultSet" class="headerlink" title="接口 ResultSet"></a>接口 ResultSet</h4><pre><code>所有超级接口： Wrapper</code></pre><p>所有已知子接口：<br>CachedRowSet, FilteredRowSet, JdbcRowSet, JoinRowSet, RowSet, SyncResolver, WebRowSet<br>public interface ResultSetextends Wrapper<br>表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。<code>`</code></p><p>　　</p><h3 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h3><p>1.每次SQL操作都需要建立和关闭连接，会消耗大量的资源，如何避免？</p><p>可以采用连接池，对连接进行统一维护，不必每次都建立和关闭。事实上这是很多对JDBC进行封装的工具所采用的。</p><p>2.Java代码中，传入的数据格式与数据库定义不同怎么办？如把Java的String对象赋值给数据库的tinyint属性。</p><p>分析：在执行SQL语句时，数据库会尝试进行转换。根据我的实验，如果用内容为纯字母的String对象传入tinyint的age属性时，会被转化成0。具体转化规则应该和数据库有关。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JBDC </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat与服务器</title>
      <link href="/2019/08/06/web/tomcat/"/>
      <url>/2019/08/06/web/tomcat/</url>
      
        <content type="html"><![CDATA[<h3 id="Tomcat端口配置"><a href="#Tomcat端口配置" class="headerlink" title="Tomcat端口配置"></a>Tomcat端口配置</h3><p>tomcat服务器需配置三个端口才能启动，安装时默认启用了这三个端口，当要运行多个tomcat服务时需要修改这三个端口，不能相同。端口配置路径为tomcat\ conf\service.xml    </p><h5 id="修改Shutdown端口（默认为8005端口）"><a href="#修改Shutdown端口（默认为8005端口）" class="headerlink" title="修改Shutdown端口（默认为8005端口）"></a>修改Shutdown端口（默认为8005端口）</h5><p><code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code>  </p><h5 id="修改http访问端口（默认为8080端口）"><a href="#修改http访问端口（默认为8080端口）" class="headerlink" title="修改http访问端口（默认为8080端口）"></a>修改http访问端口（默认为8080端口）</h5><p>负责建立HTTP连接。在通过浏览器访问Tomcat服务器的Web应用时，使用的就是这个连接器。<br><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</code><br><code>&lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;</code><br><code>&lt;!-- &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</code>  </p><h5 id="AJP协议访问端口（默认为8009端口）"><a href="#AJP协议访问端口（默认为8009端口）" class="headerlink" title="AJP协议访问端口（默认为8009端口）"></a>AJP协议访问端口（默认为8009端口）</h5><p>负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。<br><code>&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</code><br><code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>  </p><h3 id="Tomcat项目路径映射"><a href="#Tomcat项目路径映射" class="headerlink" title="Tomcat项目路径映射"></a>Tomcat项目路径映射</h3><p>假如你写好了一个web项目，并且想发布到服务器上让全国各地的人都能访问你的网站，那么就需要使用一个url地址才能访问到你的web页面(通常是ip地址+项目路径才能访问的到！)，如果你想使用IP地址直接访问你的web界面，就需要对tomcat进行一定的修改。当然如果仅仅用于测试，可以不修改这些配置，但当域名解析的时候，就需要解析到一个ipv4的地址！这个地址通常就是你的服务器IP地址。  </p><h5 id="修改如下！"><a href="#修改如下！" class="headerlink" title="修改如下！"></a>修改如下！</h5><p>打开tomcat目录进入conf\service.xml<br>1.配置默认的项目路径<br>在tomcat的server.xml中<br><code>&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;              unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;              xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;</code>  </p><p>　<code>&lt;/Host&gt;</code><br>在中间加上<br><code>&lt;Context path=&quot;&quot; docBase=&quot;/usr/local/tomcat/webapps/项目路径&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; /&gt;</code><br><img src="http://img.ahdy.top/2019-08-07_102251.png" alt><br>这个路径不可以过深，一般指到你项目文件名就可以了，因为可能造成部分css、js代码未解析使界面布局没有样式，一般指到你项目文件名就可以。<br>2.修改tomcat\conf\web.xml<br><img src="http://img.ahdy.top/2019-08-07_102421.png" alt><br>这个路径一般就是设置主页面，欢迎界面的意思，路径可以具体！<br>假如你想设置的主页面是一个jsp文件，最好配置一下，你的项目文件/WEB-INF/web.xml<br><img src="http://img.ahdy.top/2019-08-07_102516.png" alt><br>当然浏览器不能直接对文件进行修改还需要使用一文本编辑器，比如notepad++。  </p><h3 id="服务器端口开放"><a href="#服务器端口开放" class="headerlink" title="服务器端口开放"></a>服务器端口开放</h3><p>这里讲的服务器并不是tomcat，当然tomcat也有端口开放，比如，80/8080端口，你可以配置要开放的端口当然也可以两个端口都开放。<br>当你部署好了web项目的时候，可能会出现访问不到网页的情况，这种情况可能是你购买的云主机没有开放端口而造成的，具体操作如下：<br>1.进入你云主机的控制台—&gt;进入云主机实例<br><img src="http://img.ahdy.top/2019-08-07_105209.png" alt><br>2.进入安全组配置<br><img src="http://img.ahdy.top/2019-08-07_105544.png" alt><br>3.加入安全组<br><img src="http://img.ahdy.top/2019-08-07_105700.png" alt><br>4.配置规则<br><img src="http://img.ahdy.top/2019-08-07_110427.png" alt><br><img src="http://img.ahdy.top/2019-08-07_110453.png" alt><br>服务器端口已经配置完成！  </p><h5 id="80和8080端口有什么区别？没有本质上的区别，80是因特尔提供服务的默认端口，8080是阿帕奇tomcat提供服务的默认端口"><a href="#80和8080端口有什么区别？没有本质上的区别，80是因特尔提供服务的默认端口，8080是阿帕奇tomcat提供服务的默认端口" class="headerlink" title="80和8080端口有什么区别？没有本质上的区别，80是因特尔提供服务的默认端口，8080是阿帕奇tomcat提供服务的默认端口"></a>80和8080端口有什么区别？没有本质上的区别，80是因特尔提供服务的默认端口，8080是阿帕奇tomcat提供服务的默认端口</h5>]]></content>
      
      
      <categories>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL入门</title>
      <link href="/2019/08/06/web/mysql2/"/>
      <url>/2019/08/06/web/mysql2/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL的数据库创建、删除"><a href="#MySQL的数据库创建、删除" class="headerlink" title="MySQL的数据库创建、删除"></a>MySQL的数据库创建、删除</h3><p>下面为MySQL操作成功例子，相关命令我会放在本文档后面<br>1.首先，以管理员身份启动dos命令界面，切盘到MySQL的bin目录下<br><img src="http://img.ahdy.top/2019-08-06_133616.png" alt><br>2.启动MySQL服务，登陆MySQL<br><img src="http://img.ahdy.top/2019-08-06_134251.png" alt><br>3.输入<code>show databases;</code>显示MySQL当中的数据库，这些初始化的数据库，切记不可以动，它们关系着MySQL的功能是否正常运行！接着，输入了<code>create database firstdemo;</code>就成功新创建了一个数据库<br>当然也可以初始化创建数据库时对数据库的编码进行指定<br>输入<code>create database firstdemo2 character set gbk/utf8;</code>就能创建一个指定字符集编码的数据库  </p><h5 id="指定数据库编码有什么用？"><a href="#指定数据库编码有什么用？" class="headerlink" title="指定数据库编码有什么用？"></a>指定数据库编码有什么用？</h5><p>当外界数据编码于数据库编码不一致的时，数据传入进数据库里就会产生乱码，这也是最常见的问题之一！<br><img src="http://img.ahdy.top/2019-08-06_134511.png" alt><br>4.查看数据库字符集输入<code>show create database firstdemo;</code>删除数据库输入<code>drop database firstdemo;</code>之后发现firstdemo已经被删除<br><img src="http://img.ahdy.top/2019-08-06_142216.png" alt>  </p><h3 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h3><p>首先创建一个数据库然后建表,注意一定先use +数据库名才能使用建表命令，不然会报错!<br><img src="http://img.ahdy.top/2019-08-06_154548.png" alt></p><h3 id="MySQL常用SQL命令："><a href="#MySQL常用SQL命令：" class="headerlink" title="MySQL常用SQL命令："></a>MySQL常用SQL命令：</h3><h4 id="数据库相关SQL"><a href="#数据库相关SQL" class="headerlink" title="数据库相关SQL"></a>数据库相关SQL</h4><pre><code>1.查看所有数据库    show databases;2.创建数据库    -格式：create    database 数据库名    create database newdb1;    创建数据库并且指定字符集    create database newdb1 character set gbk/utf8;3.查看数据库的详情 可以查看数据库的字符集。    show create database 数据库名。    show create database newdb1;4.删除数据库    --格式：drop database 数据库名    drop database newdb2;5.使用数据库    use newdb1;#### 表相关的操作1.查看所有表    show tables;2.创建表    --格式：create table 表名(字段1 字段1 类型，字段2，字段2类型);    create table person(name varchar(10),age int);3.查看详情    show create table person;    --数据库表引擎    1.InnoDB:支持数据库的高级操作，比如：事物，外键，索引，约束等等。    2.myisam:不支持数据库的高级操作，只支持基础的增删改查。4.创建表指定引擎和字符集。    --格式：create table 表名(字段1 字段1 类型，字段2，字段2类型)engine=innodb/myisam charset=gbk/utf8;    create table t1(name varchar(10),age int)engine=innodb charset=gbk;5.查看表字段    desc t1;6.删除表    drop table t1;#### 数据相关的SQL create table hero(name varchar(10),age int);--全表插入格式：insert into 表名 values(值1,值2);insert into hero values(&#39;刘备&#39;,18);--指定字段插入    insert into hero(name) values(&#39;李白&#39;);--批量插入数据：insert into hero values(&#39;关羽&#39;,18),(&#39;张飞&#39;,18);insert into hero(name) values(&#39;李白&#39;),(&#39;白居易&#39;),(&#39;杜甫&#39;);### 查询数据    --格式：select 字段信息 from 表名 where 条件。1.查询所有数据，所有字段信息。    select * from hero;2.查询所有的名字.    select name from hero;3.查询年龄18岁人的所有信息。    seelct * from hero where age = 18;### 修改数据    --格式：update 表名 set 字段名=数据 where 过滤条件=数据.    update hero set age=25 where name=&#39;刘备&#39;;    --注意：如果不给条件则修改全表信息。### 删除数据    delete from 表名 where 条件。    delete from hero where name=&#39;杜甫&#39;;    delete from hero;  </code></pre><h3 id="MySQL常见问题汇总"><a href="#MySQL常见问题汇总" class="headerlink" title="MySQL常见问题汇总"></a>MySQL常见问题汇总</h3><h4 id="1-修改密码时，无法修改，发送异常信息"><a href="#1-修改密码时，无法修改，发送异常信息" class="headerlink" title="1.修改密码时，无法修改，发送异常信息"></a>1.修改密码时，无法修改，发送异常信息</h4><p>报错信息如下：</p><p>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that<br>corresponds to your MySQL server version for the right syntax to use near ‘(‘123<br>456’) where user=’root’’ at line 1</p><p>看过很多方法：</p><p> 总结如下：</p><p> 使用win+R 输入CMD进入dos界面。进入你的mysql安装路径下面的bin文件家里面；</p><p>先使用：mysql -u root -p 输入密码进入mysql命令窗口mysql&gt;:</p><p>修改密码：</p><p>方法1：</p><pre><code>     set password for 用户名@localhost=password(&#39;新密码&#39;)；</code></pre><p>方法2：</p><pre><code>    mysql&gt;set password =password(&#39;你的密码&#39;);    mysql&gt;flush privileges;</code></pre><p>方法3：</p><pre><code>   ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;（我采用的是这个方式进行密码修改的，前两种仍然报错）；</code></pre><h4 id="2-MySQL服务无法启动成功，服务没有报错"><a href="#2-MySQL服务无法启动成功，服务没有报错" class="headerlink" title="2.MySQL服务无法启动成功，服务没有报错"></a>2.MySQL服务无法启动成功，服务没有报错</h4><p>这种情况分为多种可能：<br>1.没有配置好ini文件<br>2.MySQL文件夹下没有date目录<br>3.系统内存在多个不同版本的MySQL服务，并且服务在运行中<br>4.端口占用<br>这些潜在问题可能不会在启动SQL时发生，我建议，在发生未知错误时推到重新来，如果你实在装不好，可以加我QQ联系，我远程给你ko！ok？嗯，下一篇—MySQL进阶。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装</title>
      <link href="/2019/08/01/web/mysql/"/>
      <url>/2019/08/01/web/mysql/</url>
      
        <content type="html"><![CDATA[<p>MySQL是什么，MySQL是目前世界上最常用的关系型数据库，数据库啊，顾名思义，它就是存放数据的地方，这些数据，可以是你的一些注册信息，年龄，邮箱，账号密码，比如你要登陆某个平台or app时，你所输入的账号密码，就会通过网络，发送请求数据，与数据库当中的信息进行校验，通过的话，就登陆成功了，不通过当然就会报异常咯。<br>    -之前通过流操作文件的方式存储数据。—弊端。<br>    1.执行效率<br>    2.进行增删改查操作，代码书写比较麻烦<br>    3.一般只能保存文本数据。</p><pre><code>Mysql是轻量级，开源的，免费的数据存储集合。#### 什么是DBDB:Database 数据库 ,指一个文件集合。#### 什么是DBMSDBMS:Database Management System 数据库管理系统,用于管理数据库的软件。常见的DBMS：Mysql、Oracle、DB2、SQLServer SQLite#### 数据库的分类1.关系型数据库：经过数学论证开源保存现实生活中的各种关系，以表为单位保存数据。2.非关系型数据库(网状型数据库):用于决绝某些特定场景 比如：高并发访问时的数据缓存。举例：Redis 以key-value形式保存数据的。</code></pre><h3 id="MySQL安装："><a href="#MySQL安装：" class="headerlink" title="MySQL安装："></a>MySQL安装：</h3><p>方式一·<a href="https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.11-winx64.zip" target="_blank" rel="noopener">直接下载</a>版本为8.0.11，如果想下载最新版请进入官网！<br>方式二·<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">官网下载</a><br>我也不知道这官网为啥这么卡….<br>进去之后大概就是这个样的，选红圈的下，不要问为啥下这个，我也不知道<br><img src="http://img.ahdy.top/2019-08-01_151652.png" alt><br>然后会进到这个页面，点击下面的，”不用，谢谢，仅开始下载（no thanks just<strong>**</strong>）”如果我翻译的不对也不要讲！<br><img src="http://img.ahdy.top/2019-08-01_151620.png" alt></p><p>方式三·<a href="https://share.weiyun.com/5BeMjhg" target="_blank" rel="noopener">网盘下载</a><br>我这里提供了一个MySQL5.6版本+Sqlyog，这个操作比较简单，解压版的，内包含启动MySQL的.bat脚本，解压好后以管理员身份启动服务就可以用了，关闭同样操作。里面有不同的版本，不要胡乱下，选择你操作系统相同的系统位数下载！  </p><h3 id="MySQL配置环境变量"><a href="#MySQL配置环境变量" class="headerlink" title="MySQL配置环境变量"></a>MySQL配置环境变量</h3><p>右键此电脑打开属性，打开高级系统设置<br><img src="http://img.ahdy.top/2019-08-06_094215.png" alt><br><img src="http://img.ahdy.top/2019-08-06_094248.png" alt><br><img src="http://img.ahdy.top/2019-08-06_094319.png" alt><br>进入系统的path变量选择新增，这个路径就是你安装好的MySQL/bin路径，将绝对路径复制粘贴进来就完成了MySQL环境变量的配置。</p><h3 id="官方版MySQL起步："><a href="#官方版MySQL起步：" class="headerlink" title="官方版MySQL起步："></a>官方版MySQL起步：</h3><p>要用MySQL，就要会sql命令，这个命令emmm就像我们的c语言一样，起到一个入门作用，官网上下载的也好，我附加上去的解压版也好，都得会sql命令才能对数据库操作，当然这是就体现了图形化工具的好处，比如navicat，sqlyog。<br>下面教你下载好后怎么对数据库初始化~<br>我相信你此时已经下载好了MySQL，并且把它解压到一个安全的地方，（不要放中文路径的文件内）<br>双击进入你解压好的文件,里面创建一个后缀为.ini的配置文件<br><img src="http://img.ahdy.top/2019-08-06_090425.png" alt></p><h5 id="文件内容如下："><a href="#文件内容如下：" class="headerlink" title="文件内容如下："></a>文件内容如下：</h5><pre class=" language-#"><code class="language-#">   [client] # 设置mysql客户端默认字符集default-character-set=utf8[mysqld] # 设置3306端口port = 3306 # 设置mysql的安装目录,这个路径关系着MySQL能否启动，解压在哪就填哪basedir=D:\\mysql-8.0.11 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 # datadir=C:\\web\\sqldata 不用动  允许最大连接数max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB </code></pre><p>到这儿MySQL的配置已经完成，下面需要对它进行初始化操作<br>1.以管理员身份打开 cmd 命令行工具，切换目录：<br><code>D:</code><br><code>cd mysql-8.0.11\bin</code><br><img src="http://img.ahdy.top/2019-08-06_091117.png" alt><br>2.初始化<br><code>mysqld --initialize --console</code><br>执行完成后，会输出 root 用户的初始默认密码，如：<br>…<br>2018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: APWCY5ws&amp;hjQ<br>…<br>APWCY5ws&amp;hjQ 就是初始密码，后续登录需要用到（注意！：请先保存或者记住它），你也可以在登陆后修改密码。</p><p>3.输入以下安装命令：</p><p><code>mysqld install</code><br>4.启动输入以下命令即可启动：</p><p><code>net start mysql</code>  </p><p><img src="http://img.ahdy.top/2019-08-01_160546.png" alt> </p><h3 id="登录-MySQL"><a href="#登录-MySQL" class="headerlink" title="登录 MySQL"></a>登录 MySQL</h3><p>当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名:</p><h5 id="mysql-h-主机名-u-用户名-p-简写法：mysql-u-root-p"><a href="#mysql-h-主机名-u-用户名-p-简写法：mysql-u-root-p" class="headerlink" title="mysql -h 主机名 -u 用户名 -p(简写法：mysql -u root -p)"></a>mysql -h 主机名 -u 用户名 -p(简写法：mysql -u root -p)</h5><p>参数说明：</p><p>-h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;<br>-u : 登录的用户名;<br>-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。<br>如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可：</p><p>mysql -u root -p<br>按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应:</p><p>Enter password:<br>若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor… 的提示语。</p><p>然后命令提示符会一直以 mysq&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录，一般默认用户名都是root，密码就是初始化的时候的密码  </p><h3 id="密码修改"><a href="#密码修改" class="headerlink" title="密码修改"></a>密码修改</h3><p><img src="http://img.ahdy.top/2019-08-06_092528.png" alt>  </p><p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code><br>登陆密码为你初始化生成的密码，在开启数据库服务的条件下，才能登陆成功  </p><p>后面123456是你修改的密码，你也可以随意更改，但最好不要包含特殊符号，because很有可能造成sqlyog等图形化工具连接报错！</p><h5 id="接下来，尽情挖掘新大陆吧-少年！下一篇—-mysql入门（MySQL—-sql命令基础操作—-常见问题）"><a href="#接下来，尽情挖掘新大陆吧-少年！下一篇—-mysql入门（MySQL—-sql命令基础操作—-常见问题）" class="headerlink" title="接下来，尽情挖掘新大陆吧,少年！下一篇—-mysql入门（MySQL—-sql命令基础操作—-常见问题）"></a>接下来，尽情挖掘新大陆吧,少年！下一篇—-mysql入门（MySQL—-sql命令基础操作—-常见问题）</h5>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用API（详细实例2）</title>
      <link href="/2019/07/29/java/java7/"/>
      <url>/2019/07/29/java/java7/</url>
      
        <content type="html"><![CDATA[<h4 id="一-Hashset集合"><a href="#一-Hashset集合" class="headerlink" title="一 Hashset集合"></a>一 Hashset集合</h4><p>这是一个无序去重的集合，在它的内部不存在重复的数据，这个原理基于<br>equalsHashset<br>虽然它是无序的，但是TreeMap弥补了这个缺陷<br><code>TreeMap &lt;Integer&gt;tree =new TreeSet&lt;&gt;();</code><br>Set集合的实现类是HashSet() 与Arraylist区别是：算法不同<br>但是2个类都是继承与Collection。<br>假如有一个数组，里面包含重复的元素，你可以按照下面的形式进行元素去重</p><pre class=" language-String[]names={&quot;tom&quot;,&quot;bob&quot;,&quot;bob&quot;};"><code class="language-String[]names={&quot;tom&quot;,&quot;bob&quot;,&quot;bob&quot;};">Set <String>stes =new Hashset<>(names);System.out.println(stes);</code></pre><h4 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h4><p> String []names={“tom”,”bob”,”bob”};<br>list<string>list =Array.alist(names);<br>System…..//输出</string></p><pre class=" language-API"><code class="language-API">list.add("???");  list.remove("???");//可以传入下标或者字符串  list.get(0);//获取某个下标值  list.set(0,"???");//修改某个下标的值  list.contains("???");//判断集合内是否有这个元素Collections.sort();//排序Collections.shuffle();//随机置换，可用于扑克牌</code></pre><h4 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h4><p><code>list&lt;String&gt;list2=new Arraylist(???);Object[]objs=list2.toArray();//无指定类型  String[]names=list.toArray(new String[]{});//转换成指定类型的数组</code> </p><h3 id="二、Map集合"><a href="#二、Map集合" class="headerlink" title="二、Map集合"></a>二、Map集合</h3><pre><code>Map集合是一个独立的集合不继承与CollectionHashTable() 是jdk1.0提供的，是线程安全的，性能比较慢HashMap()   是jdk1.2提供的，是非线程安全的，性能相对于来说快一些。Map&lt;String, String&gt; maps = new HashMap&lt;String, String&gt;();    maps.put(&quot;3866&quot;, &quot;董大炮&quot;);    maps.put(&quot;8888&quot;, &quot;剑&quot;);    maps.put(&quot;88888&quot;, &quot;Andi&quot;);    maps.put(&quot;8888&quot;, &quot;剑&quot;);    System.out.println(maps);    System.out.println(maps.get(&quot;3866&quot;));    System.out.println(maps.size());    Set&lt;Entry&lt;String, String&gt;&gt; setMap =  maps.entrySet();//遍历map    System.out.println(setMap);    System.out.println(setMap.iterator().next());    System.out.println(setMap.iterator().next().getKey());//打印Key    System.out.println(setMap.iterator().next().getValue());//打印值    Set&lt;String&gt; set = maps.keySet();    System.out.println(set);    Collection&lt;String&gt; cs =  maps.values();    System.out.println(cs);    //根据key删除元素，返回被删除的value    String rvalue = maps.remove(&quot;8888&quot;);    System.out.println(rvalue);    System.out.println(maps);    //判断是否有指定的key    System.out.println(maps.containsKey(&quot;38661&quot;));    //判断是否有指定的value    System.out.println(maps.containsValue(&quot;Andis&quot;));    Map&lt;Integer, Student&gt; stuMap = new HashMap&lt;&gt;();    stuMap.put(1, new Student(&quot;Jerry&quot;, 18));    stuMap.put(2, new Student(&quot;Jerry&quot;, 18));    System.out.println(stuMap);//hashMap中的元素重复与否与key相关，key的底层就是Set  map集合应用，统计字符串当中，每一个字出现的次数    public static void main(String[] args) {    // TODO Auto-generated method stub    NumberFormat number =NumberFormat.getInstance();    String s=&quot;如果你是在一个面临美国制裁的国家使用GitHub的在线服务，你的账号可能会因此被限制只能使用最基本的产品。GitHub 本周告诉居住在克里米亚的21岁俄罗斯公民 Anatoliy Kashkin，由于美国的贸易管制，它“限制”了他的 GitHub 账户。Anatoliy Kashkin 在 YC 上发了帖子说明此事，据说与该开发者同一地区的其他开发者也同样被限制。GitHub 确实为开发者提供了一个争议限制的申诉表格，但 Kashkin 声称通过上诉限制没有任何好处：“这是毫无意义的。我的帐户被标记为限制，为了取消标记，我必须提供一份证据证明我不住在克里米亚。我实际上是一名克里米亚人注册的俄罗斯公民，我身处其中克里米亚，我一生都住在克里米亚。”&quot;;System.out.println(s); Count(s); }public static void Count(String s) {    int count = 0 ;    String sss=null;    NumberFormat number =NumberFormat.getInstance();    HashMap&lt;Character,Integer&gt; map =new HashMap&lt;&gt;();    int point;    for (int i = 0; i &lt;s.length() ; i++)    {        if(!map.containsKey(s.charAt(i)))        {            map.put(s.charAt(i),1);            }else {                 count = map.get(s.charAt(i));                count++;                map.put(s.charAt(i),count);                }         sss=number.format((float)map.get(s.charAt(i))/(float)s.length()*100);            System.out.println(sss);        }    System.out.println(map);System.out.println(&quot;\r&quot;);}</code></pre><h3 id="三、集合的继承结构"><a href="#三、集合的继承结构" class="headerlink" title="三、集合的继承结构"></a>三、集合的继承结构</h3><pre><code>                Collection        List                    Set                                MapArrayList    LinkedList        HashSet    SortedSet                HashMap        HashTable        SortedMap                                    TreeSet                                Properties        TreeMap以上是集合的继承结构，请务必知悉。</code></pre><h3 id="四、集合的复制"><a href="#四、集合的复制" class="headerlink" title="四、集合的复制"></a>四、集合的复制</h3><pre><code>Java默认的复制规则是浅层复制集合复制有2种形式1.clone()  是Object定义的.一般API都重写了这个方法2.使用复制构造器    List&lt;Entry&lt;String, Object&gt;&gt; lists = new ArrayList&lt;&gt;(map.entrySet());</code></pre><h4 id="五、同步化-线程安全"><a href="#五、同步化-线程安全" class="headerlink" title="五、同步化(线程安全)"></a>五、同步化(线程安全)</h4><pre><code>Collections.synchronizedList(list)可以将非线程安全的list包装为一个线程安全的如果将一个非线程安全的list包装为一个线程安全的转换以后就相当于VectorCollections.synchronizedMap(Map)可以将非线程安全的Map包装为一个线程安全的  </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用API（详细实例1）</title>
      <link href="/2019/07/28/java/java6/"/>
      <url>/2019/07/28/java/java6/</url>
      
        <content type="html"><![CDATA[<h3 id="一、String-字符串"><a href="#一、String-字符串" class="headerlink" title="一、String 字符串"></a>一、String 字符串</h3><p>String是一个API提供的类，存放字符串。底层是char[]String字面量相同时，会替换为同一个String对象的引用。常量连接的结果也被优化为一个字符串.<br>String比较的时候用equals</p><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>在字符串当中使用加号（a+=b）可以对字符串进行拼接<br>也可以使用StringfBuffer类进行拼接，元素插入<br>例如：<br><code>`</code> StringBuilder buider = new StringBuilder();<br>    buider.append(“李敖先生”).append(“的前妻”).append(“胡因梦女士”).insert(0, “大师”).append(“据说十分漂亮”).delet(4, 6);<br>    System.out.println(buider);</p><pre><code>相比较String而言StringBuffer的性能更加高效  可以通过:   System.currentTimeMillis();  对比如二者效率### 二、静态字符串Java编译期间(javac)，凡是字面量和常量的运算，都会先算出结果运行期当字符串池有String&quot;字面量&quot;时，Java会直接用，如果没有才创建。  &quot;&quot;就是一个对象 String是一个特殊的类### 三、API``` charAt()        根据指定的index下标返回指定的字符    length()        返回字符串的长度    trim();            去除前后两端的空白 \n \t \s    toLoweCase()    将字符串变为小写    toUpperCase()    将字符串变为大写    indexOf(String str) 根据指定的字符串返回下标            lastIndexof()    返回最后一次出现的指定字符的下标位置    endsWith()        是否已指定的后缀结尾    startsWith()    是否已指定的前缀开始    subString(int start,int end)    截取一段子字符串(包前不包后)    subString(int start)        截取一段子字符串(包前不包后)    tocharArray()    将字符串转换成一个数组    split()            根据既定的字符进行分割字符串    equalsIgnoreCase() 忽略大小写比较</code></pre><h3 id="四、StringBuilder、StringBuffer"><a href="#四、StringBuilder、StringBuffer" class="headerlink" title="四、StringBuilder、StringBuffer"></a>四、StringBuilder、StringBuffer</h3><pre><code>StringBuilder内部也是对char数组的操作，但是数组内容是可变的，如果长度不够，利用数组边长算法来维护自动扩容长度。StringBuffer 是线程安全的，速度比较慢StringBuilder 非线程安全的，速度比较快StringBuilder与StringBuffer API几乎一模一样</code></pre><h3 id="五、日期"><a href="#五、日期" class="headerlink" title="五、日期"></a>五、日期</h3><pre><code>Date    long + 操作(很多API的方法已经过时了。有BUG)Calender    long + 操作(一般情况都使用Calender)</code></pre><pre><code>     Date内部维护着一个long值     即：1970年至今的毫秒数    Date date = new Date();    System.out.println(date);    long time = date.getTime();    System.out.println(System.currentTimeMillis());    System.out.println(time);</code></pre><pre><code>SimpleDateFormat    Date + 操作  (日期格式的操作)</code></pre><h4 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h4><p><code>`</code> String dt = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss EE”).format(calender.getTime());<br>        System.out.println(dt);</p><pre><code>### 六   一、集合    集合底层就是数组    集合的底层就是对象数组 = Object[] objs = new Object[n];    List    LinkedList            LinkedList实现了List接口，能进行队列操作。    LinkedList实现了Deque接口， 能当做双端队列使用。(即：头，尾操作,类似于栈)    #### 解析：  ``` LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();        /****************基本操作**********************/        linkedList.addFirst(0);//添加元素到列表开头        linkedList.add(1);//在列表结尾添加元素        linkedList.add(2, 2);//在指定位置添加元素        linkedList.addLast(3);//添加元素到列表结尾        System.out.println(&quot;linkedList:&quot; + linkedList);            //获取数据        System.out.println(&quot;getFirst():&quot; +linkedList.getFirst());//返回集合中第一个元素        System.out.println(&quot;getLast():&quot; + linkedList.getLast());//返回集合中的最后一个元素        System.out.println(&quot;removeFirst():&quot; + linkedList.removeFirst());//移除并返回集合中的第一个元素        System.out.println(&quot;removeLast():&quot; + linkedList.removeLast());//移除并返回集合中的最后一个元素        System.out.println(&quot;linkedList:&quot; + linkedList);        System.out.println(&quot;contains(1):&quot; + linkedList.contains(1));//判断此集合中指定的元素，如果包含返回true 否则false         位置访问操作        System.out.println(&quot;------------------------------------------------&quot;);        linkedList.set(1, 3);//将此集合中指定位置的元素替换成指定的元素        System.out.println(&quot;After set :&quot; + linkedList);        System.out.println(linkedList.get(1));//获取指定下标位置的元素        linkedList.add(3);        System.out.println(&quot;linkedList:&quot; + linkedList);        System.out.println(&quot;indexOf(3)：&quot; + linkedList.indexOf(3));//返回集合中首次出现的指定元素的索引        System.out.println(&quot;lastIndexOf(3)：&quot; + linkedList.lastIndexOf(3));////返回集合中最后一次出现的指定元素的索引        /*****************Queue操作***********************/        System.out.println(&quot;------------------------------------------&quot;);        //linkedList.clear();//清除集合中所有的元素        System.out.println(linkedList.peek());   //获取但不移除此列表的头        System.out.println(linkedList.element());//获取但不移除此列表的头        //linkedList.clear();//清除集合中所有的元素        /*         * poll()与remove()差异在于poll返回null remove 抛异常         */        System.out.println(&quot;poll():&quot; + linkedList.poll());//获取并移除此列表的头        System.out.println(&quot;After poll :&quot; + linkedList);        System.out.println(&quot;remove():&quot; + linkedList.remove());//获取并移除此列表的头        System.out.println(&quot;After remove :&quot; + linkedList);        System.out.println(&quot;linkedList:&quot; + linkedList);        linkedList.offer(4);//添加元素到列表结尾        System.out.println(&quot;linkedList:&quot; + linkedList);        linkedList.offerFirst(2);//在此列表的开头插入指定元素        System.out.println(&quot;linkedList:&quot; + linkedList);        linkedList.offerLast(5);//在此列表的结尾插入指定元素        System.out.println(&quot;linkedList:&quot; + linkedList);        System.out.println(&quot;-------------------------------------------&quot;);        System.out.println(linkedList.peekFirst());//获取但不移除此列表的头        System.out.println(&quot;linkedList:&quot; + linkedList);        System.out.println(linkedList.peekLast());//获取但不移除此列表的尾部        linkedList.pollFirst();//获取并且移除此列表的头        linkedList.pollLast();//获取并且移除此列表的尾部        linkedList.push(2);//将元素推入此列表所表示的堆栈(插入到列表的头)        System.out.println(&quot;linkedList:&quot; + linkedList);        linkedList.pop();//从此列表所表示的堆栈弹出一个元素(获取并移除第一个元素)        System.out.println(&quot;linkedList:&quot; + linkedList);        linkedList.add(3);        linkedList.removeLastOccurrence(3);//从此列表中移除最后一次出现的指定的元素(遍历)        System.out.println(&quot;linkedList:&quot; + linkedList);        /**********************遍历操作***********************/        System.out.println(&quot;----------------------------&quot;);        linkedList.clear();        for (int i = 0; i &lt; 1000000; i++) {            linkedList.add(i);        }        //迭代器遍历        long start = System.currentTimeMillis();        //获取迭代器        Iterator&lt;Integer&gt; iterator = linkedList.iterator();        /*         * hasNext():判断集合中有没有元素，如果有返回true 否则false         */        while(iterator.hasNext()) {            iterator.next();        }        long end  = System.currentTimeMillis();        System.out.println(&quot;iterator:&quot; + (end - start) + &quot;ms&quot;);        //顺序迭代(随机遍历)/*        start = System.currentTimeMillis();        for (int i = 0; i &lt;linkedList.size(); i++) {            linkedList.get(i);        }        end  = System.currentTimeMillis();        System.out.println(&quot;for:&quot; + (end - start) + &quot;ms&quot;);*/        //foreach循环迭代        start = System.currentTimeMillis();        for (Integer integer : linkedList) {}        end  = System.currentTimeMillis();        System.out.println(&quot;foreach:&quot; + (end - start) + &quot;ms&quot;);        LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();        temp.addAll(linkedList);        //通过pollFirst或者pollLast来遍历        start = System.currentTimeMillis();        while(linkedList.size()!=0) {            linkedList.pollFirst();        }        end  = System.currentTimeMillis();        System.out.println(&quot;pollFirst:&quot; + (end - start) + &quot;ms&quot;);        System.out.println(linkedList);        //通过removeFirst或者removeLast来遍历        start = System.currentTimeMillis();        while(temp.size()!=0) {            temp.removeFirst();        }        end  = System.currentTimeMillis();        System.out.println(&quot;removeFirst:&quot; + (end - start) + &quot;ms&quot;);    }</code></pre><pre><code>ArrayListArrayList底层是由数组支持，而LinkedList是由双向链表支持的，其中的每个对象包含数据的同时还包含指向链表中前一个与后一个元素的引用.线性算法。``` ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add(&quot;one&quot;);    list.add(&quot;two&quot;);    list.add(&quot;three&quot;);    list.add(&quot;four&quot;);    System.out.println(list);    list.remove(2);    System.out.println(list);    list.add(0, &quot;aaa&quot;);    System.out.println(list);    String one = list.get(1);//获取指定下标所对应的元素    System.out.println(one);    list.set(1, &quot;2&quot;);    System.out.println(list);    String old = list.remove(1);    System.out.println(old);    System.out.println(list);    //contains 查看此集合中是否包含指定的元素，如果有 true 否则false    boolean flag = list.contains(&quot;aaa&quot;);    System.out.println(flag);    //isEmpty() 检索次列表是否为空    boolean f = list.isEmpty();    System.out.println(f);    System.out.println(list);    //截取一个子集合,按照包前不包后的原则    List&lt;String&gt; list2 = list.subList(1, 2);    System.out.println(list2);    List&lt;String&gt; list3 = new ArrayList&lt;&gt;();    list3.add(&quot;5&quot;);    list3.add(&quot;6&quot;);    list.addAll(list3);    System.out.println(list);}</code></pre><pre><code>```         List&lt;User&gt; list = new ArrayList&lt;&gt;();        User u1 = new User(&quot;Tom&quot;, &quot;123456&quot;);        User u2 = new User(&quot;Tom&quot;, &quot;123456&quot;);        User u3 = new User(&quot;Tom&quot;, &quot;123456&quot;);        System.out.println(u1.equals(u3));//true        list.add(u1);        list.add(u2);        System.out.println(list);        boolean f = list.remove(new User(&quot;Tom&quot;, &quot;123456&quot;));        System.out.println(f);        System.out.println(list);        boolean f2 = list.contains(new User(&quot;Tom&quot;, &quot;123456&quot;));        System.out.println(f2);//true        /**************************/        LinkedList&lt;User&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add(u1);        linkedList.add(u2);        System.out.println(linkedList);        boolean f3 = linkedList.contains(new User(&quot;Tom&quot;, &quot;123456&quot;));        System.out.println(f3);//true        /*         * LinkedList中 如果方法中包含First或者last 都不会去隐含调用equals和hashCode         */    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java数组</title>
      <link href="/2019/07/27/java/java3/"/>
      <url>/2019/07/27/java/java3/</url>
      
        <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组的声明方式："><a href="#数组的声明方式：" class="headerlink" title="数组的声明方式："></a>数组的声明方式：</h4><h5 id="1-动态初始化"><a href="#1-动态初始化" class="headerlink" title="1.动态初始化"></a>1.动态初始化</h5><h5 id="2-静态初始化"><a href="#2-静态初始化" class="headerlink" title="2.静态初始化"></a>2.静态初始化</h5><p>动态数组一般就理解成可以无限扩大的容器，二而静态数组就是一开始设定时就规定了其大小<br>动态初始化指在创建时，使用了new对象的方式创建：  </p><p>####格式为：  </p><h5 id="int-arr-new-int-4"><a href="#int-arr-new-int-4" class="headerlink" title="int arr[] =new int [4];"></a>int arr[] =new int [4];</h5><h5 id="int-arr-new-int-1-2-3-4"><a href="#int-arr-new-int-1-2-3-4" class="headerlink" title="int []arr=new int[]{1,2,3,4};"></a>int []arr=new int[]{1,2,3,4};</h5><h4 id="静态初始化个格式："><a href="#静态初始化个格式：" class="headerlink" title="静态初始化个格式："></a>静态初始化个格式：</h4><h5 id="int-arr-1-2-3-4"><a href="#int-arr-1-2-3-4" class="headerlink" title="int arr[]={1,2,3,4};"></a>int arr[]={1,2,3,4};</h5><p>动态是运行期间确定元素值，静态是编译期间确定元素值 ，静态数组一经建立不可以更改。<br>复制扩容的方法改变；</p><h3 id="1-arrays-copyof-src-length-src表示数组名，length表示长度"><a href="#1-arrays-copyof-src-length-src表示数组名，length表示长度" class="headerlink" title="1.arrays.copyof(src,length);src表示数组名，length表示长度"></a>1.arrays.copyof(src,length);src表示数组名，length表示长度</h3><h3 id="2-System-arraycopy-src-srcpos-dest-destpos-length"><a href="#2-System-arraycopy-src-srcpos-dest-destpos-length" class="headerlink" title="2.System.arraycopy(src,srcpos,dest,destpos,length);"></a>2.System.arraycopy(src,srcpos,dest,destpos,length);</h3><p>其中<br>src：数组源  （被复制）<br>srcpos：原数组开始复制的位置<br>dest：目标数组（当前希望复制的数组）<br>destpos：目标数组复制的位置<br>length：复制长度   </p><p>数组的访问都是，从0开始，0表示数组开始的下标<br>数组定义格式</p><h3 id="数组输出方式："><a href="#数组输出方式：" class="headerlink" title="数组输出方式："></a>数组输出方式：</h3><h4 id="System-out-println-arrays-tostring-XX"><a href="#System-out-println-arrays-tostring-XX" class="headerlink" title="System.out.println(arrays.tostring(XX));"></a>System.out.println(arrays.tostring(XX));</h4><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>public class ArrSortDemo {<br>    public static void main(String[] args) {<br>        Integer[] ary = {2,7,9,3,6,8,1};<br>  //1.可以使用Arrays.sort对数组进行排序<br>        Arrays.sort(ary);<br>        System.out.println(Arrays.toString(ary));<br>        //2.Comparator:是一个接口，这个接口中的compare的方法是自定义排序方法<br>        Arrays.sort(ary,new Comparator<integer>() {<br>            @Override<br>            public int compare(Integer o1, Integer o2) {<br>                return o2-o1;<br>            }<br>        });<br>        System.out.println(Arrays.toString(ary));<br>    }<br>}</integer></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><pre><code>栈内存：栈内存是计算机的一种数据存储方式，是Java进程启动的时候在内存中开辟的存储空间。栈内存利用遵循LIFO(后进先出)原则Java中所有的局部变量都在栈内存中分配空间(压入)，方法的参数(形参)也是局部变量，局部变量离开作用域时，收回(从栈内存中弹出)。Java方法调用使用栈实现，递归调用就是栈的操作。</code></pre><p>注意：递归的时候按照递归深度分配全部临时变量，栈内存开销极大，性能不好。<br>在使用递归调用的时候，切记要有跳出条件。如果没有跳出条件，就会爆栈.</p><p>什么时候使用递归？<br>    尽可能不使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组,递归 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2019/07/23/markdown/"/>
      <url>/2019/07/23/markdown/</url>
      
        <content type="html"><![CDATA[<h5 id="内容如图"><a href="#内容如图" class="headerlink" title="内容如图"></a>内容如图</h5><p>为啥上图呢，因为我的文档就是markdown写的，直接写的话会对文档产生效果，so。<br><img src="http://img.ahdy.top/20190723103212.png" alt><br><img src="http://img.ahdy.top/20190723103225.png" alt><br><img src="http://img.ahdy.top/20190723103233.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java难点</title>
      <link href="/2019/07/22/java/java5/"/>
      <url>/2019/07/22/java/java5/</url>
      
        <content type="html"><![CDATA[<h3 id="•-继承"><a href="#•-继承" class="headerlink" title="•  继承"></a>•  继承</h3><p>exdents 关键字 是继承的意思<br>Object类</p><pre><code>Java类默认继承于Object，任何类都继承了Object类的所有属性和方法，其中有三个方法，比较重要：1.toString()    重写了对象的内容。如果不重写toString()，打印对象会打印出地址值。如果重写toString()，将打印toString()方法返回    的指定的字符串。2.equals();    用来比较两个对象是否相等的方法    比较对象分为两种：&quot;引用相等&quot;与&quot;对象相等&quot;    比较引用值是否相等，使用 &quot;==&quot;    比较对象是否相等，使用&quot;equals&quot;    但是 equals需要被重写，因为Object的类的equals方法就是 ==    eques默认的比较规则是地址值的比较。    如果覆盖的话，请规循比较规则：    自反性：    对称性:    传递性:    一致性:3.hashCode();    hachCode方法要与equals方法一同覆盖(规定)    当两个对象equals比较为true时，应具有相同的hashCode值    当两个对象equals比较为false时,应具有不同的hashCode值    hashCode值要稳定，一个对象创建以后就应该在变化。    默认的hashCode值是当前堆对象地址值转换的一个整数，这个整数不是内存地址。    一般使用对象的OID值作为hashCode值。    IOD是对象的唯一编号，在项目中一般采用数据库生成IOD，也就是数据库中的&quot;主键&quot;.</code></pre><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写是发生在父类与子类之间的。</p><p>父类方法被子类方法重写后，一定调用子类的。</p><h3 id="•-多态"><a href="#•-多态" class="headerlink" title="•  多态"></a>•  多态</h3><p>父类引用指向子类实例。</p><p>重写，重载都是多态的一种。</p><p>方法动态绑定对象</p><p>属性静态绑定变量类型</p><h3 id="•-继承中的构造器"><a href="#•-继承中的构造器" class="headerlink" title="•  继承中的构造器"></a>•  继承中的构造器</h3><p>子类构造器一定默认调用父类无参构造器。</p><p>子类优先调用父类无参构造器开辟内存空间,所以，父类空间先加载。</p><h3 id="•-对象的实例化过程"><a href="#•-对象的实例化过程" class="headerlink" title="•  对象的实例化过程"></a>•  对象的实例化过程</h3><h5 id="•-在创建类之前，检查类是否被加载-是将硬盘上的-class文件加载到内存中-，如果没有加载就加载这个类-在这个类被挤在之前要加载所有的父类。"><a href="#•-在创建类之前，检查类是否被加载-是将硬盘上的-class文件加载到内存中-，如果没有加载就加载这个类-在这个类被挤在之前要加载所有的父类。" class="headerlink" title="•  在创建类之前，检查类是否被加载(是将硬盘上的.class文件加载到内存中)，如果没有加载就加载这个类.在这个类被挤在之前要加载所有的父类。"></a>•  在创建类之前，检查类是否被加载(是将硬盘上的.class文件加载到内存中)，如果没有加载就加载这个类.在这个类被挤在之前要加载所有的父类。</h5><p>Java运行时采用的策略：懒惰式加载(按需加载)：如果第一次用到就加载，只加载一次，通过CLASSPATH指定的路径寻找文件(.class),加载以后是一个对象，类型Class.</p><h5 id="•-在内存堆中分配对象空间。递归分配其所有父类和子类属性空间。属性默认自动初始化。"><a href="#•-在内存堆中分配对象空间。递归分配其所有父类和子类属性空间。属性默认自动初始化。" class="headerlink" title="•  在内存堆中分配对象空间。递归分配其所有父类和子类属性空间。属性默认自动初始化。"></a>•  在内存堆中分配对象空间。递归分配其所有父类和子类属性空间。属性默认自动初始化。</h5><p>•  进行属性赋值</p><p>•  递归调用父类构造器(无参)</p><p>•  调用本类构造器</p><p>•  引用类型的转换</p><p>向上转换(隐式/自动类型转换)，是小类型到大类型的转换</p><p>向下转换(强制类型转换),是大类型到小类型的转换</p><p>instanceof 运算符 ,用来检查引用对象的类型,经常与引用类型的强制类型转换配合，实现安全的类型转换，避免类型转换异常。</p><h3 id="•-接口"><a href="#•-接口" class="headerlink" title="•  接口"></a>•  接口</h3><p>我们使用抽象方法或者抽象类来作为系统的分析和设计的工具。用来实现客户关系管理业务的架构。</p><p>接口的特性：</p><p>接口是特殊的抽象类</p><p>接口用来表示纯抽象的概念，没有任何具体的方法。</p><p>接口不能被实例化，可以定义变量</p><p>接口变量可以引用具体实现类的实例(多态)</p><p>接口只能被实现(继承)一个具体类实现接口，必须实现其所有的抽象方法。</p><p>接口的属性，默认是常量public static final</p><p>接口之间可以继承</p><p>一个具体的类可以实现多个接口，实现多继承现象。</p><p>接口中的方法一定是抽象方法。默认缺失public abstract xxx</p><p>实现接口，使用关键字implements，实际上是一种继承关系。</p><h3 id="•-抽象类"><a href="#•-抽象类" class="headerlink" title="•  抽象类"></a>•  抽象类</h3><p>只有行为的概念，没有具体的实现。</p><p>抽象类中的方法可以是抽象方法，也可以被具体化。抽象类不是纯抽象概念</p><p>包含抽象方法的类一定是抽象类。抽象类不能被实例化。只能定义引用变量</p><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><pre><code>Java中的访问控制修饰符是修饰Java中类、属性、方法的课间范围。public 任意protected 类        包内        子类[default] 类        包内private        类同一个.java文件当中只能有一个public修饰的类</code></pre><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><pre><code>静态修饰符.1.static修饰的资源属于类级别，是全体对象实例共享的资源静态属性    使用static修饰，属于整个类的属性。    静态资源是在类加载期间初始化的    静态资源可以直接使用类名.资源名访问。比如：System.out实例属性    属于对象的属性    必须要有对象才能够访问。静态代码块是在类加载期间运行的代码块，由于类只加载一次，所以静态代码块只执行一次。一般用来在类加载以后初始化一些静态资源的时候使用。</code></pre><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><pre><code>final修饰的类，不能被继承final修饰方法不能被重写final修饰的变量，初始化以后就不能再修改</code></pre><h3 id="JavaBean规范（开发规范）"><a href="#JavaBean规范（开发规范）" class="headerlink" title="JavaBean规范（开发规范）"></a>JavaBean规范（开发规范）</h3><pre><code>JavaBean不是语法规范，是习惯性编程规范，用这个规范写的类比较方便。有的时候，JavaBean的类也称为：POJO类(Plan Old Java Object)简化规范：1.必须有包    项目名、包名、类名、等路径名，不要使用中文。2.Java类，具有无参数构造器3.属性尽可能私有化，方法尽可能公开化    属性私有后提供set、get方法。4.必须实现序列化接口JDK提供的类几乎都符合JavaBean规范。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象类|接口 </tag>
            
            <tag> 访问控制符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名</title>
      <link href="/2019/07/22/yuming/"/>
      <url>/2019/07/22/yuming/</url>
      
        <content type="html"><![CDATA[<h5 id="域名是什么呢？"><a href="#域名是什么呢？" class="headerlink" title="域名是什么呢？"></a>域名是什么呢？</h5><p>我就不解释了昂，不懂可以<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062?fr=aladdin" target="_blank" rel="noopener">百度百科</a>  </p><h5 id="域名获取"><a href="#域名获取" class="headerlink" title="域名获取"></a>域名获取</h5><p>域名在各大服务器运营商可以买到，国内几个知名云，阿里云，腾讯云，百度云，华为云，都可以。只需要百度一下进入他们官网实名认证一下就可以购买了，一般价格在1~？元不等。  </p><h5 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h5><p><img src="http://img.ahdy.top/2019-07-22_192041.png" alt><br>如果你购买了一个域名需要完成备案才能正常使用它，备案的过程比较漫长，一般提交审核一个月左右会完成，以前比较麻烦现在可以通过app上传照片及一些相关信息就能完成备案了，以我备案阿里域名的经历，他们会初级审核，如果你有地方不合格他们会电话通知你，直到达到备案所需的最低要求，一般他们审核过再提交给信管局基本上不会有问题。  </p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>假如你已经有了一个成功备案的域名<br>此时你希望通过域名来访问你的网站，那么就要对域名添加解析记录，将ip地址映射给域名  </p><h5 id="如果你的网站不能直接通过ip地址来访问就需要去修改服务器参数，这里的服务器一般指tomcat等服务器，修改sever-xml-web-xml两个文件，可以指定IP地址访问项目路径下的网站主页，一般默认为index-html，当然这些都是可以修改的，详细操作请百度一下。"><a href="#如果你的网站不能直接通过ip地址来访问就需要去修改服务器参数，这里的服务器一般指tomcat等服务器，修改sever-xml-web-xml两个文件，可以指定IP地址访问项目路径下的网站主页，一般默认为index-html，当然这些都是可以修改的，详细操作请百度一下。" class="headerlink" title="如果你的网站不能直接通过ip地址来访问就需要去修改服务器参数，这里的服务器一般指tomcat等服务器，修改sever.xml,web.xml两个文件，可以指定IP地址访问项目路径下的网站主页，一般默认为index.html，当然这些都是可以修改的，详细操作请百度一下。"></a>如果你的网站不能直接通过ip地址来访问就需要去修改服务器参数，这里的服务器一般指tomcat等服务器，修改sever.xml,web.xml两个文件，可以指定IP地址访问项目路径下的网站主页，一般默认为index.html，当然这些都是可以修改的，详细操作请百度一下。</h5><p>过程如图所示（其他云服务器类似）</p><h5 id="打开控制台"><a href="#打开控制台" class="headerlink" title="打开控制台"></a>打开控制台</h5><p><img src="http://img.ahdy.top/2019-07-22_192335.png" alt></p><h5 id="选择域名"><a href="#选择域名" class="headerlink" title="选择域名"></a>选择域名</h5><p><img src="http://img.ahdy.top/2019-07-22_192442.png" alt></p><h5 id="选择解析"><a href="#选择解析" class="headerlink" title="选择解析"></a>选择解析</h5><p><img src="http://img.ahdy.top/2019-07-22_192522.png" alt></p><h5 id="添加解析记录"><a href="#添加解析记录" class="headerlink" title="添加解析记录"></a>添加解析记录</h5><p><img src="http://img.ahdy.top/2019-07-22_193513.png" alt></p><h4 id="二级域名创建"><a href="#二级域名创建" class="headerlink" title="二级域名创建"></a>二级域名创建</h4><p>步骤一样，选择CNAME<br><img src="http://img.ahdy.top/2019-07-22_195021.png" alt><br>确定后大概十分钟就会生效  </p><h5 id="二级域名应用"><a href="#二级域名应用" class="headerlink" title="二级域名应用"></a>二级域名应用</h5><p>主域名通常用来访问我们的主网页<br>1.二级域名就是主域名分出来域名。</p><p>2.二级域名是寄存在主域名之下的域名，权重低于主域名。</p><p>3.二级域名属于一个独立的分支，他有自己的收录、快照、PR值、反链等。</p><p>4.当主域名受到惩罚，二级域名也会连带惩罚。<br>二级域名可以重定向一个url地址，并且它是免费的，比如以七牛云为例子，七牛云的对象储存会提供一个测试域名，这个测试域名一个月后就会销毁，那么这个测试测试域名所生成的外链都会失效，这时候你就可以绑定一个二级域名用于dns加速，只需要将你绑定二级域名生成的CNAME复制粘贴到域名解析CNAME记录值内就可以了<br><img src="http://img.ahdy.top/2019-07-22_195142.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 域名 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
            <tag> 二级域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/2019/07/18/java/java4/"/>
      <url>/2019/07/18/java/java4/</url>
      
        <content type="html"><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="什么是Object-对象-？"><a href="#什么是Object-对象-？" class="headerlink" title="什么是Object(对象)？"></a>什么是Object(对象)？</h4><p>Object是指一个具体的事物实例。<br>面向对象的定义。<br>首先根据客户需求抽象出业务对象，然后对需求进行合理分层。构建相对独立的业务模块，之后设计业务逻辑，利用多态，继承，封装，抽象的编程思想，实现业务需求，最后通过整合各个模块，达到高类聚，低耦合的效果，满足客户需求。</p><h3 id="面向对象分析-面向对象设计"><a href="#面向对象分析-面向对象设计" class="headerlink" title="面向对象分析/面向对象设计"></a>面向对象分析/面向对象设计</h3><p>软件企业广泛采用的一项有效技术，OOAD 在设计中要映射现实生活中指定问题领域中的对象和实体。这种设计要尽可能的接近于现实，即，以最自然的方式表述实体。所以说，面向对象技术的有点就是能构建与现实世界相对应的问题模型，并且保持结构、关系、行为。</p><h3 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h3><p>类型(类) 指一个名词的概念<br>引用(变量) 指引用具体概念实例的代词。<br>对象(东西) 指具体概念的个体实例<br>行为    指具体实例的功能/函数/方法<br>多态    行为或者引用，在具体情形下会发生变化的现象。<br>在Java中，多态多表示父类引用指向子类实例<br>封装    任何对象实例都是尽可能封装，减少暴露它的实现细节是不可见的<br>继承    增强代码的可复用性,抽取业务功能的共性。</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><h4 id="什么是构造器？"><a href="#什么是构造器？" class="headerlink" title="什么是构造器？"></a>什么是构造器？</h4><p>构造对象的函数。<br>构造器的特点：<br>Java中的构造器(构造方法)声明在类内部<br>方法名与类名一直的方法叫构造方法<br>构造方法不能声明返回值类型<br>构造方法可以包含参数，参数一般是创建对象实例必须依赖的条件。<br>任何类都一定有构造器，如果程序员不写构造器，JVM会自动的为该类添<br>一个无参构造器。<br>构造器重载<br>构造器重载指写多个参数不一样的构造器。</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>指当前对象。</p><h4 id="四、方法的重载"><a href="#四、方法的重载" class="headerlink" title="四、方法的重载"></a>四、方法的重载</h4><p>方法的重载是发生在同类中的，方法名一样，方法签名不一样的方法，称为重载。<br>方法的重载与返回值无关。<br>多态，功能的多样性。</p><h3 id="Java参数的传递规则"><a href="#Java参数的传递规则" class="headerlink" title="Java参数的传递规则"></a>Java参数的传递规则</h3><p>Java是基于值的传递，是变量值的复制.<br>基本类型就是其中的值的复制<br>引用类型就是地址值的复制</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>提高代码的复用性。抽取业务功能的共通性。<br>继承中有两个概念：<br>父类<br>用来抽取共性代码。<br>子类</p>]]></content>
      
      
      <categories>
          
          <category> Java面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java变量与二进制</title>
      <link href="/2019/07/16/java/java2/"/>
      <url>/2019/07/16/java/java2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><p>一、    变量<br>变量相当于自然语言中的代词。比如：“您好”中的您。</p><h3 id="a-变量的分类"><a href="#a-变量的分类" class="headerlink" title="a)    变量的分类"></a>a)    变量的分类</h3><ol><li>成员变量(实例变量、全局变量)-写在类中的</li><li>局部变量(写在方法中的)—随时回收—GC—System.GC</li><li>常量 —不可变<h4 id="b-变量有哪些规则"><a href="#b-变量有哪些规则" class="headerlink" title="b)    变量有哪些规则"></a>b)    变量有哪些规则</h4>Java是强类型语言，在使用变量时，有既定的规则：</li><li>变量必须声明，并初始化以后才能使用</li><li>变量必须有明确的类型</li><li>变量不能重复定义(在相同代码域中)</li><li>变量有作用域<h3 id="二、-进制"><a href="#二、-进制" class="headerlink" title="二、    进制"></a>二、    进制</h3>1.10进制<br>十进制(逢10进1)<br>23678(10进制)=2 <em> 10000 + 3</em> 1000 + 6<em>100 + 7</em> 10 + 8*1<pre><code>            =2*10^4 + 3*10^3+ 6*10^2 + 7*10^1 + 8*10^0            =23678</code></pre></li></ol><h3 id="2-二进制"><a href="#2-二进制" class="headerlink" title="2.二进制"></a>2.二进制</h3><p>   逢2进1 基数是2的进制。<br>权：128 64 32 16 8 4 2 1<br>   15 =  0000 1111<br>   0100 0001(2进制) = 65</p><h3 id="4-补码"><a href="#4-补码" class="headerlink" title="4.    补码"></a>4.    补码</h3><p>1000  -8<br>1001  -7<br>1010  -6<br>1011  -5<br>1100  -4<br>1101   -3<br>1110   -2<br>1111   -1<br>0000   0<br>0001   1<br>0010   2<br>0011   3<br>0100   4<br>0101   5<br>0110  6<br>0111   7<br>在二进制中，符号位(最高位)为0的是正数，为1的是负数.</p><p>-1 + 1 = 0<br>1111 + 0001 = 0<br>        1111</p><pre><code>+        0001    0000</code></pre><p> 在封闭的四位运算中，(超出4位就丢弃)</p><p>1101   -3  ~0010 + 1<br>0011  3      0011<br>计算机中正数和负数的关系是取反加一。举例：~3 + 1 = -3（表示对3取反）<br>补码运算是封闭的，运算结果保留在补码范围内，超出范围就溢出。<br>补码有边界溢出风险。<br>4位二进制补码最多能表示2^4（16）个数，数的范围是-8 7</p><h3 id="16进制："><a href="#16进制：" class="headerlink" title="16进制："></a>16进制：</h3><p>0 – f<br>十六进制中的一个数代表了二进制中4位<br>1234567890<br>二进制：01001001100101100000001011010010<br>十六进制：499602d2</p><p>192</p><p>256 – 192  64<br>二进制：0000000011000000<br>十六进制：00c0</p><p>0xf4;(十六进制的书写形式)<br>二进制：1111 0100<br>十进制：128 + 64 + 32 + 16 + 4 = 244</p><h3 id="三、-Java的数据类型"><a href="#三、-Java的数据类型" class="headerlink" title="三、    Java的数据类型"></a>三、    Java的数据类型</h3><p>Java中的数据类型，分为引用类型和基本数据类型，基本类型有8种。<br>基本数据类型<br>整形：byte short int long<br>浮点型 float double<br>字符型char<br>布尔型boolean</p><h3 id="a-整数类型"><a href="#a-整数类型" class="headerlink" title="a)    整数类型"></a>a)    整数类型</h3><p>byte  8位  0x7f   0x80<br>short  16位   0x7fff  0x8000<br>int 32位    0x7fffffff 0x80000000<br>long 64  …   …</p><h3 id="b-浮点数类型"><a href="#b-浮点数类型" class="headerlink" title="b)    浮点数类型"></a>b)    浮点数类型</h3><p>float 32位 float的精度是23位(即能精确表达23位的数，超过就被截取)<br>不精确，很少被使用。<br>用小数表示的数据类型</p><p>double 类型能表示64位<br>double精确度比int精确，但是不如long<br>需要注意的是：浮点数的字面量默认就是double</p><h3 id="c-字符类型"><a href="#c-字符类型" class="headerlink" title="c)    字符类型"></a>c)    字符类型</h3><p>char 经常用到的，必须掌握，字符类型是一个16位无符号位的整数。<br>这个数是一个字符的unicode编码值。<br>Unicode编码值 是全球范围内的编码方法，编制了英文，中，日，韩，阿拉伯，希伯来等等共65535个字符.<br>Java中的char 的范围是0-65535<br>Unicode编码中英文部分与Ascii码兼容(ASCII表示0-128)<br>编码是什么？在计算机中不能写字，只能有0和1表示的数。<br>人为规定某个数除了表示一个数还可以表示一个字符。<br>一个10进制的65 代表的字符就是大写的A。</p><h3 id="d-布尔类型"><a href="#d-布尔类型" class="headerlink" title="d)    布尔类型"></a>d)    布尔类型</h3><p>布尔类型：boolean 表示真(true)假(false)</p><h3 id="四、-数据类型的转换"><a href="#四、-数据类型的转换" class="headerlink" title="四、    数据类型的转换"></a>四、    数据类型的转换</h3><p>自动类型转换<br>小类型到大类型的转换称为自动类型转换，是自动完成的。也叫隐式类型转换。<br>一般不需要处理，规则是：符号位会自动扩展，负数补1，正数不0.保证补码数值不变。</p><p>强制类型转换<br>这种转换有风险，会溢出，或者损失精度。要注意数据范围。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 变量 进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局域网内的不速之客（2）</title>
      <link href="/2019/07/15/attark/arp2/"/>
      <url>/2019/07/15/attark/arp2/</url>
      
        <content type="html"><![CDATA[<p>如果arp攻击是断网，那么arp欺骗就是对数据流量的截获，其实原理很简单，就是以kali系统为目标主机向路由器说我就是你要发送信号的主机，这样kali在开启ip地址转发的情况下，上网所经的数据流量经过kali主机，kali就能对其进行图片，账号密码的截获，当然并不是能百分之百截获到，只能获取到一部分，但这样已经会造成很大的安全问题！</p><h3 id="cat-proc-sys-net-ipv4-ip-forward"><a href="#cat-proc-sys-net-ipv4-ip-forward" class="headerlink" title="cat /proc/sys/net/ipv4/ip_forward"></a>cat /proc/sys/net/ipv4/ip_forward</h3><p>   //查看kali系统是否开启了ip地址转发（其中0表示没有开起1表示开启）</p><h3 id="echo-1-gt-proc-sys-net-ipv4-ip-forward"><a href="#echo-1-gt-proc-sys-net-ipv4-ip-forward" class="headerlink" title="echo 1 &gt;/proc/sys/net/ipv4/ip_forward"></a>echo 1 &gt;/proc/sys/net/ipv4/ip_forward</h3><p>  // 临时修改kali系统开启ip地址转发（开启IP地址转发，目标主机依然可以上网，但网络质量可能会很差）</p><h4 id="如何使kali系统永久开启ip地址转发？"><a href="#如何使kali系统永久开启ip地址转发？" class="headerlink" title="//如何使kali系统永久开启ip地址转发？"></a>//如何使kali系统永久开启ip地址转发？</h4><p>输入命令：vim /etc/sysctl.conf<br>找到对应的命令行，net ipv4.ip forward=1;将警号去掉即可永久生效，或者复制命令行在命令下，带警号这样就起到了注释的作用<br>这时候kali系统就相当于一个路由器，可以实现ip地址的转发<br>输入命令</p><h4 id="arpspoof-i-eth0-t-192-168-43-129-192-168-43-5"><a href="#arpspoof-i-eth0-t-192-168-43-129-192-168-43-5" class="headerlink" title="arpspoof -i eth0 -t 192.168.43.129 192.168.43.5"></a>arpspoof -i eth0 -t 192.168.43.129 192.168.43.5</h4><p>另外在开启一个终端窗口</p><h4 id="driftnet-i-eth0"><a href="#driftnet-i-eth0" class="headerlink" title="driftnet -i eth0"></a>driftnet -i eth0</h4><h4 id="抓到本地：driftnet-i-eth0-d-home-路径"><a href="#抓到本地：driftnet-i-eth0-d-home-路径" class="headerlink" title="抓到本地：driftnet -i eth0 -d /home/**(路径)"></a>抓到本地：driftnet -i eth0 -d /home/<em>**</em>(路径)</h4><h3 id="2-图形化工具"><a href="#2-图形化工具" class="headerlink" title="2.图形化工具"></a>2.图形化工具</h3><h4 id="ettercap-–-help-查看参数"><a href="#ettercap-–-help-查看参数" class="headerlink" title="ettercap – help 查看参数"></a>ettercap – help 查看参数</h4><h4 id="ettercap-G-进入图形化管理界面，扫描端口下存活主机，将网关IP地址加到atark1目标主机添加到atark2选择Mitm-gt-ArP毒化"><a href="#ettercap-G-进入图形化管理界面，扫描端口下存活主机，将网关IP地址加到atark1目标主机添加到atark2选择Mitm-gt-ArP毒化" class="headerlink" title="ettercap - G //进入图形化管理界面，扫描端口下存活主机，将网关IP地址加到atark1目标主机添加到atark2选择Mitm-&gt;ArP毒化"></a>ettercap - G //进入图形化管理界面，扫描端口下存活主机，将网关IP地址加到atark1目标主机添加到atark2选择Mitm-&gt;ArP毒化</h4><h4 id="ettercap-i-eth0-Tq-M-arp-remote-192-168-43-129-192-168-43-144"><a href="#ettercap-i-eth0-Tq-M-arp-remote-192-168-43-129-192-168-43-144" class="headerlink" title="ettercap -i eth0 -Tq -M arp:remote //192.168.43.129// //192.168.43.144//"></a>ettercap -i eth0 -Tq -M arp:remote //192.168.43.129// //192.168.43.144//</h4><p>其中 tq是静态文本，M为中间人攻击，格式严谨<br>开启攻击—底部出现help，那么一般情况下就是启动成功了<br>这时候再使用driftnet -i eth0<br>对图片进行截获，不知道为啥但是感觉图形化工具比较好用，截获图片数量也比较多</p><h3 id="3-获取用户登陆密码及账号"><a href="#3-获取用户登陆密码及账号" class="headerlink" title="3.获取用户登陆密码及账号"></a>3.获取用户登陆密码及账号</h3><p>我做了靶机测试，发现并不是所有账号密码都可以截获现在很多网站采用https传输协议，即使截到了也不一定是明文，通常是通过某些特殊算法进行加密<br>so，懂我意思吧！</p><h3 id="步骤，开启两个终端，输入命令"><a href="#步骤，开启两个终端，输入命令" class="headerlink" title="步骤，开启两个终端，输入命令"></a>步骤，开启两个终端，输入命令</h3><h4 id="1-echo-1-gt-proc-sys-net-ipv4-ip-forward（终端1）"><a href="#1-echo-1-gt-proc-sys-net-ipv4-ip-forward（终端1）" class="headerlink" title="1.echo 1 &gt;/proc/sys/net/ipv4/ip_forward（终端1）"></a>1.echo 1 &gt;/proc/sys/net/ipv4/ip_forward（终端1）</h4><h4 id="2-arpspoof-i-eth0-t-192-168-43-129-192-168-43-5（终端1，前一个ip地址是目标ip，后一个主机地址是网关，这个语法通俗点讲就是告诉路由器我是你要发送信息的目标）"><a href="#2-arpspoof-i-eth0-t-192-168-43-129-192-168-43-5（终端1，前一个ip地址是目标ip，后一个主机地址是网关，这个语法通俗点讲就是告诉路由器我是你要发送信息的目标）" class="headerlink" title="2.arpspoof -i eth0 -t 192.168.43.129 192.168.43.5（终端1，前一个ip地址是目标ip，后一个主机地址是网关，这个语法通俗点讲就是告诉路由器我是你要发送信息的目标）"></a>2.arpspoof -i eth0 -t 192.168.43.129 192.168.43.5（终端1，前一个ip地址是目标ip，后一个主机地址是网关，这个语法通俗点讲就是告诉路由器我是你要发送信息的目标）</h4><h4 id="3-ettercap-Tq-i-eth0（终端2，开启静态文本监听模式）"><a href="#3-ettercap-Tq-i-eth0（终端2，开启静态文本监听模式）" class="headerlink" title="3.ettercap -Tq -i eth0（终端2，开启静态文本监听模式）"></a>3.ettercap -Tq -i eth0（终端2，开启静态文本监听模式）</h4><p>基本上输入号这三个命令就完成了对目标主机账号密码的监听，随着时代进步，手工输入密码的形式渐渐被扫描二维码登陆所代替。</p>]]></content>
      
      
      <categories>
          
          <category> Arp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转发 </tag>
            
            <tag> 截获 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java环境变量</title>
      <link href="/2019/07/11/java/java/"/>
      <url>/2019/07/11/java/java/</url>
      
        <content type="html"><![CDATA[<h2 id="如何配置Java环境变量"><a href="#如何配置Java环境变量" class="headerlink" title="如何配置Java环境变量"></a>如何配置Java环境变量</h2><h3 id="1-下载1-8版本的JDK-傻瓜式安装，（一路默认选择）"><a href="#1-下载1-8版本的JDK-傻瓜式安装，（一路默认选择）" class="headerlink" title="1.    下载1.8版本的JDK -傻瓜式安装，（一路默认选择）"></a>1.    下载1.8版本的JDK -傻瓜式安装，（一路默认选择）</h3><h3 id="2-Java环境变量配置："><a href="#2-Java环境变量配置：" class="headerlink" title="2.    Java环境变量配置："></a>2.    Java环境变量配置：</h3><p>a)    JAVA_HOME</p><h5 id="i-首先右击-计算机-进入-属性-然后选择其中的-高级系统设置"><a href="#i-首先右击-计算机-进入-属性-然后选择其中的-高级系统设置" class="headerlink" title="i.    首先右击[计算机]进入[属性]然后选择其中的[高级系统设置]"></a>i.    首先右击[计算机]进入[属性]然后选择其中的[高级系统设置]</h5><p>点击进入[高级]中的[环境变量]，进入环境变量编辑界面。<br>变量名：JAVA_HOME<br>变量值：实际的安装路径（jdk所在的路径，通常默认在c盘programfile—&gt;java文件内）</p><h5 id="b-Path变量的设置"><a href="#b-Path变量的设置" class="headerlink" title="b)    Path变量的设置"></a>b)    Path变量的设置</h5><p>i.    同样是在[系统变量中]，我们可以看到path变量已经存在，那么我们只需要点击编辑即可。  </p><h5 id="变量值：-JAVA-HOME-bin-JAVA-HOME-jre-bin"><a href="#变量值：-JAVA-HOME-bin-JAVA-HOME-jre-bin" class="headerlink" title="变量值：%JAVA_HOME%\bin; %JAVA_HOME%\jre\bin;"></a>变量值：%JAVA_HOME%\bin; %JAVA_HOME%\jre\bin;</h5><h5 id="bug："><a href="#bug：" class="headerlink" title="bug："></a>bug：</h5><p>我在配置path环境变量的时候发生了一个小问题，按%Java_HOME%,这个是相对路径，但是在dos界面Javac却找不到命令，于是我将path变量新增了jre和jdk/bin目录（绝对路径）后这个问题得到了解决</p><h4 id="c-Classpath"><a href="#c-Classpath" class="headerlink" title="c)    Classpath:"></a>c)    Classpath:</h4><h5 id="变量值：-java-home-lib-java-home-lib-tools-jar"><a href="#变量值：-java-home-lib-java-home-lib-tools-jar" class="headerlink" title="变量值：.;%java_home%\lib;%java_home%\lib\tools.jar;"></a>变量值：.;%java_home%\lib;%java_home%\lib\tools.jar;</h5><h3 id="二、-Java环境变量配置详解"><a href="#二、-Java环境变量配置详解" class="headerlink" title="二、    Java环境变量配置详解"></a>二、    Java环境变量配置详解</h3><h4 id="1-JAVA-HOME"><a href="#1-JAVA-HOME" class="headerlink" title="1.    JAVA_HOME"></a>1.    JAVA_HOME</h4><p>为了方便引用，例如你jdk安装在C：/xxx/xx/xx目录里，则设置JAVA_HOME为该目录的引用。那么以后你要使用这个路径的时候，只需要输入%JAVA_HOME%即可。</p><h4 id="2-path"><a href="#2-path" class="headerlink" title="2.    path"></a>2.    path</h4><p>你想在任何时候都使用%JAVA_HOME%\bin\java命令来执行可行性文件吗？显然不会。于是你可以选择把%JAVA_HOME%\bin\java添加到PATH路径下。这样我们就可以在任何路径下只用java执行命令.</p><h4 id="3-classpath"><a href="#3-classpath" class="headerlink" title="3.    classpath"></a>3.    classpath</h4><p>为了程序能够找到相应的.class文件。举个例子：编译一个JAVA程序A.java<br>会得到一个A.class的类文件。在当前目录下执行java A 将会得到相应的结果<br>(前提是已经设置CLASSPATH为”.”)现在，把A.class移到别的目录下，在执行<br>Java A 将会抛出java.lang.NoClassDelFoundError异常。因为找不到.class文件。<br>现在你把CLASSPATH增加为你转移的目录在运行，结果才会正常。<br>总之一句话去高阔classpath：加载被编译过的.java文件，使之可以找到对应的.class文件。  </p><h5 id="总结：一共需要配置三个环境变量，每个环境变量所对应的执行条件不同，环境变量的配置意味着操作系统能否找到并成功执行java文件"><a href="#总结：一共需要配置三个环境变量，每个环境变量所对应的执行条件不同，环境变量的配置意味着操作系统能否找到并成功执行java文件" class="headerlink" title="总结：一共需要配置三个环境变量，每个环境变量所对应的执行条件不同，环境变量的配置意味着操作系统能否找到并成功执行java文件"></a>总结：一共需要配置三个环境变量，每个环境变量所对应的执行条件不同，环境变量的配置意味着操作系统能否找到并成功执行java文件</h5><h5 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h5><p>JDK :就是Java开发工具包<br>JRE：就是Java运行时环境<br>JVM：Java虚拟机<br>Java Se API：就是Java系统核心类库<br>JDK包含了JRE</p><p>JavaSe:基础<br>JavaEE：web企业级应用开发<br>JavaMe：Android</p><h4 id="问题：-jar包是什么？封装好的jar包是否能得到源码？"><a href="#问题：-jar包是什么？封装好的jar包是否能得到源码？" class="headerlink" title="问题： jar包是什么？封装好的jar包是否能得到源码？"></a>问题： jar包是什么？封装好的jar包是否能得到源码？</h4><h4 id="答：jar包实际上是一个压缩文件，类似-rar，jar包通常叫第三方库，框架，其实就是别人写好的工具类，通过反编译就能得到源码。"><a href="#答：jar包实际上是一个压缩文件，类似-rar，jar包通常叫第三方库，框架，其实就是别人写好的工具类，通过反编译就能得到源码。" class="headerlink" title="答：jar包实际上是一个压缩文件，类似.rar，jar包通常叫第三方库，框架，其实就是别人写好的工具类，通过反编译就能得到源码。"></a>答：jar包实际上是一个压缩文件，类似.rar，jar包通常叫第三方库，框架，其实就是别人写好的工具类，通过反编译就能得到源码。</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闲散</title>
      <link href="/2019/07/08/composition/"/>
      <url>/2019/07/08/composition/</url>
      
        <content type="html"><![CDATA[<p>我也是无语啦，写了三千字，没保存，so 使用markdown一定要选启用自动保存啊！！！<br>没啥好命名的题目，随便开始写吧！<br>在我过去一年的大学生涯里，我深刻的体会到了当代大学生的迷惘和困惑。一进学校就开始焦虑自己的未来，非常功利的规划自己每一步，我要怎么怎么样，但现实是残酷的，其实我高中时并不是这样的人，那时我行我素，固步自封，用俗话讲就是头铁吧！下面讲个故事吧，所谓事情的发展总是两面性的，物极必反，在那样“头铁”的性子下，我离家出走了，我一直认为一个人也可以生活的很好，然而…还是那句话，现实是残酷的，很快我身上带的钱所剩无几，这意味着我不赚钱将会面临挨饿，那是我第一次感受到危机感，迫于生活，我找到了一家中介公司，中介以强硬的态度让我签下很多份含有不平等条约的合同，当时，我还有些高兴，我找到工作了，但这只是故事的开始。<br>我如期的进到了一家洗衣液外包工厂，老油条们都喜欢欺负新人，什么重活脏活都给我，车间头儿也是有点小权时时刻刻发挥到极致，我任劳任怨的虚度着光阴，我其实是一个利他主义者，或许这种行为的本质就是内心善良吧，然而这种善良并不会被人们珍惜，反而会被肆意践踏。直到有一天我被调到厂里流水线作业量最大的生产线上，我因为跟不上巨大的工作量，boss直接要开除我，并扬言不会给一分钱工钱。<br>从小就听老师讲，有问题找警察，嗯，于是我就报警啦，然而警察告诉我，这方面事情，他们管不了，这种事要去劳动局，申诉，劳动仲裁，法院起诉，一系列流程，我深刻的意识到这个时间我是耗不起的，当时啊真的是穷困潦倒，风餐露宿。不知道你们报没报过警，他们如果出动了警力，需要对报警人信息做一个备案，就这样我还被带去派出所一趟。没办法我还是去了劳动局，我等了很久排上号，那个服务区的人就给我一种有理也没地方说的感觉吧！最后那人讲了一句，小兄弟回家吧！别出来打工了，他就喊了下一号，顿时什么贪污受贿，狼狈为奸，官官相护出现在我的脑海，我不甘，在那等了一夜，第二天他一上班我又来了，我如愿的要到了一张申诉表，最后经过“他们”之间的协商，给了我三百块钱，我记得当时干了十天，一天十二小时吧，十天我就被开除了，因为啥啊，就因为我是临时的呗，这是资本主义管用的手法，杀一儆百。嗯，当时就一个想法，以后不想再那么累，我又想到父亲说的一些话，韵味深长。所以呢我写这个故事希望能前车之鉴，让你有些感悟少走些弯路。  </p><p>#####努力不一定成功，也不一定就有什么结果，但你努力过就会有收获（经历）。  </p><p>身边的很多人，焦虑为什么别人目标那么明确，自己却没有那么清晰。出于某种补偿心理，他们会一方面参加各种各样的社团活动，社会实践，另一-方面门门考试逼着自己拿A。其实在这种全方面恶性竞争的生态下，只会造就两种人，全面彻底的输家，和全面彻底的但是却是insecured overacheivers的赢家。都说大学教育正在堕落成为失去灵魂的卓越，当然这不是大学问题，而是后现代性的社会出现的必然问题，在此不表，有空另开小灶。但是在我看来，更可忧虑的是那些赢家并不因此成就”卓越”，反倒可能因为熟谙了各种潜规则而变成蝇营狗苟的现实主义者，与此相对，输家则因为遭遇挫或不公而成为愤世嫉俗者和犬儒主义者。无论是哪一种结果，都以丧失灵魂为代价。所以这就是为什么部分大学生涯里我在我的四周自己给自己修起了一座高墙，自己不想出去，也不准别人走进的原因:当谈论的只是各种八卦新闻、网络游戏或说纯粹的男欢女爱，这样的大学一定不可能是卓越的，因为它背离了大学的本义。<br>或许长此以往，我也会变成那种我曾经讨厌的人，此时我想起一首歌<br>有人浪迹江湖，有人寒窗苦读</p><p>有人阿谀奉承，有人早已麻木</p><p>有人嫌贫爱富，有人唯利是图</p><p>有人精打细算，有人满不在乎  </p><p>为此我经常体会到了自己的矛盾，我，你，都是社会性体会。要在社会里走下去，必须要玩社会本身的游戏规则，尤其潜规则玩好比实打实的规则更重要。至于如何调整、引导这个矛盾，是我一直在学习的一件事情。我目前的方法是:是专注。走不出去，，那就专注的做好每件事情吧，那就把它做到极致吧。每个人都在寻找那个可以用尽全身气力去拥抱的对象，并且希望这个拥抱可以让自己变得安全、强大甚至完满。但随着年复一年的变更，我越来越认同昂山素季的这个说法“真正的改变是通过理解、同情、正义、爱心后的内在变化。”只有经历了如此这般的内在变化，你才会和自己停战，才能够学会不自负、不迟疑、也不骄慢”地与世界媾和。小至个体，大到国家，概莫能外。  </p><p>我总是亦步亦趋，因为我害怕失败，其实不过是自尊心作祟，我已经是个彻彻底底的loser，我还有什么释怀不了呢，其实最大的敌人莫过于自己，加油！</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经历 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站开发概述（2）</title>
      <link href="/2019/06/27/web/web2/"/>
      <url>/2019/06/27/web/web2/</url>
      
        <content type="html"><![CDATA[<h3 id="材料准备："><a href="#材料准备：" class="headerlink" title="材料准备："></a>材料准备：</h3><p>1.云服务器–以我的服务器为例子<br><img src="http://img.ahdy.top/2019-06-27_172422.png" alt><br>2.tomcat服务器（这时候可能有些人会懵，这两个服务器有啥区别，云服务器呢就是放tomcat的服务器，而tomcat服务器是存放你项目的服务器，它们是一种从属，包含关系）这里附上tomcat的下载连接(自带jdk-我都叫它解压版的tomcat)<br><a href="https://share.weiyun.com/57Wjpp2" target="_blank" rel="noopener">tomcat</a><br>3.你的项目</p><h3 id="远程连接："><a href="#远程连接：" class="headerlink" title="远程连接："></a>远程连接：</h3><p>第一步，首先要对你的云服务器进行环境部署，那么这极为重要的一步就是要通过远程桌面连接上服务器<br>1.右键点击开始点击运行（快捷键win+R）在命令行内输入mstsc<br><img src="http://img.ahdy.top/2019-06-27_172423.png" alt><br>2.输入本机计算机用户名（administrator），和需要连接的服务器公网ip地址<br><img src="http://img.ahdy.top/2019-06-27_172424.png" alt><br>3.输入服务器的密码<br><img src="http://img.ahdy.top/2019-06-27_172425.png" alt><br>4.连接成功<br><img src="http://img.ahdy.top/2019-06-27_214328.png" alt></p><h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><p>将下载好的 websever（tomcat）打包复制粘贴到服务器上<br>解压后把项目放到下图路径内<br><img src="http://img.ahdy.top/2019-06-27_214613.png" alt><br><img src="http://img.ahdy.top/2019-06-27_214831.png" alt><br>启动tomcat服务器<br><img src="http://img.ahdy.top/2019-06-27_215101.png" alt><br>出现如上图字样服务器运行成功，此时dos界面不可以关闭，在浏览器内输入公网的IP地址就你能访问的网站<br>以我的项目演示<br><img src="http://img.ahdy.top/2019-06-27_215356.png" alt><br>此时静态网站发布完成！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一、本机测试<br>在HBuilder里测试<br>在WebServer里测试<br>二、部署到公网服务器<br>申请一台公网服务器 ( 阿里云/腾讯云/百度云)<br>远程登录上去，把WebServer.zip拷上去<br>把网站项目文件拷贝到 webapps\ROOT\下<br>启动服务</p><h5 id="后续loading"><a href="#后续loading" class="headerlink" title="后续loading"></a>后续loading</h5><p>动态网站开发概述与项目发布</p>]]></content>
      
      
      <categories>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态网站 </tag>
            
            <tag> 发布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站开发概述（1）</title>
      <link href="/2019/06/26/web/web1/"/>
      <url>/2019/06/26/web/web1/</url>
      
        <content type="html"><![CDATA[<h5 id="你是否也想拥有一个自己的网站呢？"><a href="#你是否也想拥有一个自己的网站呢？" class="headerlink" title="你是否也想拥有一个自己的网站呢？"></a>你是否也想拥有一个自己的网站呢？</h5><p>接下来的网站系列我会概述，制作一个静态网站所需要的东西，以及将制作好的项目发布到服务器上的教程。</p><p>####### 网站类型：网站呢！它分为静态网站和动态网站，所谓静态网站就是没有后台的，作为静态展示用的网站<br>动态的，大家一般就理解成有后台支持的，可以通过后台修改网页内容的网站那种（这里的后台指后台管理操作，有数据库支持，能对网站做出更新的功能）</p><h5 id="1-开发软件的安装-HBuilder（这款编译器有很强的代码索引功能，写起代码非常轻松）"><a href="#1-开发软件的安装-HBuilder（这款编译器有很强的代码索引功能，写起代码非常轻松）" class="headerlink" title="1.开发软件的安装 HBuilder（这款编译器有很强的代码索引功能，写起代码非常轻松）"></a>1.开发软件的安装 HBuilder（这款编译器有很强的代码索引功能，写起代码非常轻松）</h5><p>这里附上HBuilder的安装包地址—<a href="https://share.weiyun.com/5AOIOrI" target="_blank" rel="noopener">腾讯微云</a>—<br>安装好了之后你就可以开始开发一个静态网站了！一个静态网站基本需要会html的标签语法加上css布局和一定的js水平<br>如果是小白的话不用担心，可以自学，这里跟一些比较好的自学网站地址<br><a href="https://www.runoob.com/" target="_blank" rel="noopener">菜鸟教程</a>  <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a></p><h5 id="2-网站发布概述"><a href="#2-网站发布概述" class="headerlink" title="2.网站发布概述"></a>2.网站发布概述</h5><p>发布网站，想让全国各地的人访问到你的网站，就要把你制作好的网站发布到服务器上（服务器呢它虽然叫服务器，其实它就是一台不关机的电脑，不知道你是否了解远程连接，远程访问，可以这么理解服务器它就是任何用户都可以访问的一台电脑）<br>嗯！可能解释的有些抽象，但当你有了一台自己的服务器的时候，你会发现我说的非常通俗易懂！哈哈<br>这时候你会产生疑问，我的项目该放在服务器的哪个地方呢！这里就需要说到应用层服务器，阿帕奇的tomcat，这个东西它能自动解析你的项目，一主默认的主网页都是index.html，它解析过了之后呢，你运行它通常就是出来一个dos界面里面显示几月几月份<br>然后你通过你服务器公网的ip地址就能直接访问到你的网站了！</p><h5 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3.环境搭建"></a>3.环境搭建</h5><p>当你手中有一个比较完善的项目的时候，这时候就需要将web项目进行部署<br>1.你需要一台服务器来运行你的项目，服务器哪里买呢，中国四大服务器运营商，什么阿里，腾讯，华为，百度，我是买的阿里的，阿里有个云翼计划（活动），对学生优惠9.5一个月服务器，很便宜，可以玩很久.<br>2.你需要一个域名来解析你的服务器公网ip地址，（这时候可能有人会疑问，什么是域名呢，域名它实际上是一个网址，一般都是万维网www开头的，通过这个域名就能访问你的网站内容，嗯，是不是很容易理解呢）<br>3.你需要将tomecat或其他..安装到服务器上，并配置jdk环境</p><h4 id="4-内网穿透（把自己电脑当成服务器）"><a href="#4-内网穿透（把自己电脑当成服务器）" class="headerlink" title="4.内网穿透（把自己电脑当成服务器）"></a>4.内网穿透（把自己电脑当成服务器）</h4><p>比如有些人不想买服务器，或者我没有钱买怎么办呢，在网站教程系列的末尾，<br>会出一篇关于使用《花生壳内网穿透的教程》，这个原理很容易明白就是把你的电脑ip地址映射到公网上，这样别人就能通过浏览器来访问你的网站，嗯，但是也有弊端，自己的电脑需要一直开着，并且会使它不安全，或者出现上行不够的情况</p>]]></content>
      
      
      <categories>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概述 </tag>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局域网内的不速之客（1）</title>
      <link href="/2019/06/13/attark/arp1/"/>
      <url>/2019/06/13/attark/arp1/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.ahdy.top/2019-06-13_175422.png" alt="@子龙"><br>当你在虚拟机中安装好了kali系统的时候（如上图所示），kali系统包含众多脚本，可以帮助我们做很多测试，下面主要介绍Arp攻击的原理及教程</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP（Address Resolution Protocol，地址解析协议）是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的进行。</p><h3 id="ARP攻击的局限性"><a href="#ARP攻击的局限性" class="headerlink" title="ARP攻击的局限性"></a>ARP攻击的局限性</h3><p>ARP攻击仅能在以太网（局域网如：机房、内网、公司网络等）进行。</p><p>无法对外网（互联网、非本区域内的局域网）进行攻击。</p><h3 id="ARP攻击的攻击原理"><a href="#ARP攻击的攻击原理" class="headerlink" title="ARP攻击的攻击原理"></a>ARP攻击的攻击原理</h3><p>ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。</p><h2 id="在Kali-Linux环境下的实现ARP攻击"><a href="#在Kali-Linux环境下的实现ARP攻击" class="headerlink" title="在Kali Linux环境下的实现ARP攻击"></a>在Kali Linux环境下的实现ARP攻击</h2><p>攻击环境<br>攻击主机：Kali Linux </p><p>IP：192.168.1.13</p><p>被攻击主机：Windows 10</p><p>IP：192.168.1.10</p><p>因为是在虚拟机环境下实现的攻击，所以要提前将虚拟机的网络适配器设置为桥接模式，这样一来虚拟机便可以单独获得一个ip地址，而不是和NAT模式下一样和宿主机共用一个ip地址。</p><h3 id="ARP断网攻击（更多攻击手段持续更新ing）"><a href="#ARP断网攻击（更多攻击手段持续更新ing）" class="headerlink" title="ARP断网攻击（更多攻击手段持续更新ing）"></a>ARP断网攻击（更多攻击手段持续更新ing）</h3><p>在进行攻击的时候我们需要先知道自己的IP地址，在终端中输入ifconfig指令即可（所说的终端是kali系统中的cmd在左侧任务栏内，一般是第二个）</p><p><img src="http://img.ahdy.top/2019-06-13_181357.png" alt></p><p>在知道了自己IP地址的情况下，我们同时也知道了自己所在的网段，接下来我们可以找一下当前局域网下还存在哪些主机，<br>如果想看自己电脑连接的那台路由器上的网管输入ipconfig查看<br><img src="http://img.ahdy.top/2019-06-13_183724.png" alt><br>这里使用nmap脚本（nmap可以扫描出当前路由器下被占用的端口，通俗点讲就是这些端口都是有人在使用的！）出于道德我演示攻击自己的电脑为例子！<br>命令：namp -sP 192.168.1.*<br>后面的是网关ip，不是绝对的，网关地址在上图中可以看到<br><img src="http://img.ahdy.top/2019-06-13_183837.png" alt><br><img src="http://img.ahdy.top/2019-06-13_183911.png" alt><br>可以看到我们已经通过namp命令扫描出了当前路由器下的ip<br>对比上下图，我们可以发现我们的目标ip的确也是在列表中的，这个时候目标还是可以正常上网的</p><p>此时，在Kali中使用arpspoof工具实现ARP攻击<br>攻击命令：Arpspoof -i eth0 -t 192.168.1.10 -t 192.168.1.1<br>ip就是目标ip加上网关地址<br><img src="http://img.ahdy.top/2019-06-13_185319.png" alt><br><img src="http://img.ahdy.top/2019-06-13_185346.png" alt></p><p>这个时候的目标已经无法正常上网了</p><p><img src="http://img.ahdy.top/2019-06-13_185512.png" alt></p><p>停止ARP攻击，目标就能恢复到正常上网状态<br>快捷键是（Ctrl+c）结束攻击！</p>]]></content>
      
      
      <categories>
          
          <category> Arp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻击 </tag>
            
            <tag> 断网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踏上渗透之路</title>
      <link href="/2019/06/11/attark/frist/"/>
      <url>/2019/06/11/attark/frist/</url>
      
        <content type="html"><![CDATA[<p>在我们翻开一本关于开发类的书籍的时候都会看到一句：“工欲善其事必先利其器”，这句话给我们的意思呢大概就是，要想学好编程，首先得有开发工具，接下来，我就来讲怎么安装Linux kali 系统的环境，这时候很多人会产生疑惑，不久是个系统吗直接装不就好了？为啥还要环境，由于kali系统是全root模式安全性为0，容易被病毒入侵，不利于测试，几乎很少有人把它直接装在自己的电脑硬盘上，所以这时候我们有需要一个虚拟机，（简单说一下虚拟机的概念：虚拟机它就是可以模拟各种系统运行的一个软件，通常都指-VMware）<br><a href="https://blog.csdn.net/baijinswpu/article/details/80835417" target="_blank" rel="noopener">虚拟机安装教程</a></p><p>这时候呢你电脑上已经有虚拟机软件了，接下来就需要linux kali的镜像文件进行安装到虚拟机上就ok了<br>注意网络模式要设为桥接！还有就是密匙网上都有！随便搜一下就永久免费啦！下面附上kali系统的安装教程。<br><a href="https://blog.csdn.net/qq_40950957/article/details/80468030" target="_blank" rel="noopener">kali系统安装教程</a></p><p>到这我相信你已经安装好了kali系统的环境！！！，如果有问题可以点博客下的企鹅咨询我！</p>]]></content>
      
      
      <categories>
          
          <category> kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kali </tag>
            
            <tag> 环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于本站</title>
      <link href="/2019/06/09/web/aboutweb/"/>
      <url>/2019/06/09/web/aboutweb/</url>
      
        <content type="html"><![CDATA[<p>我是个非常懒的人，非常不自律，嗯，可能在老师眼里我就是那个学习吊儿郎当，不踏实的学生，虽然老师们没有直说，但我还是能看清自己，俗话说的好知错能改就是好孩子，<br>所以呢！我决定时常反省一下自己，没事就写写博客吧！起初没想好写些什么，圈子里都讲不想当黑客的程序员不是好程序员，于是我想写写关于linux kali渗透测试的东西，<br>其实黑客的概念非常广泛，就像白帽子于黑帽子那样，嗯，可以想一下白天白帽子晚上黑帽子（当然这是开玩笑的！）学习这方面东西是要有一定原则的，不能去干那啥事情！在这儿我将会分享一些技术，希望能激起你对计算机的兴趣！</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智慧树刷课秘籍</title>
      <link href="/2019/05/18/class/"/>
      <url>/2019/05/18/class/</url>
      
        <content type="html"><![CDATA[<p>网课可以自己刷，很多人花钱去弄，我觉得没必要，简述一下最安全的刷课方法，你看了之后，或许可以利用它赚钱，话不多说，</p><p>登陆！<br>登上之后选择你要看的一门课，然后播放，一般浏览器按f12就会调出开发者模式，建议用谷歌，这个下学期写网页也会用到，将下面一段js代码复制粘贴到开发者模式下的console窗口内<br>代码从下面var开始复制，js中只有var类型变量..话不多说<br><code>var ti = $(&quot;body&quot;);var video = $(&quot;.catalogue_ul1 li[id*=video-]&quot;);var i = 1;var v = 1;video.css(&quot;color&quot;, &quot;blue&quot;);console.log(&quot;已选取&quot; + video.length + &quot;个小节,并已用蓝色标明,请检查是否有遗漏,如有遗漏,概不负责&quot;);setTimeout(function () {    $(&#39;.speedTab15&#39;).click();    $(&#39;.volumeIcon&#39;).click();    console.log(&quot;已进行静音和1.5倍加速&quot;);}, 3000);ti.on(&quot;DOMNodeInserted&quot;, function (e) {    if (e.target.textContent == &quot;关闭&quot;) {        console.log(&quot;检测到第&quot; + i + &quot;个弹题窗口&quot;);        window.setTimeout(function () {            document.getElementById(&quot;tmDialog_iframe&quot;).contentWindow.document.getElementsByClassName(&quot;answerOption&quot;)[0].getElementsByTagName(&quot;input&quot;)[0].click();            $(&quot;.popbtn_cancel&quot;).click();            console.log(&quot;已关闭&quot;);        }, 3000);        i++;    } else if (e.target.textContent == &quot;本节视频,累计观看时间『100%』&quot;) {        console.log(&quot;检测到视频观看完成，准备跳到下一节&quot;);        $(&#39;.next_lesson_bg&#39;).find(&#39;a&#39;).trigger(&#39;click&#39;);        console.log(&quot;已跳转&quot;);        setTimeout(function () {            $(&#39;.volumeIcon&#39;).click();            $(&#39;.speedTab15&#39;).click();            console.log(&quot;已进行静音和1.5倍加速&quot;);        }, 6000);        v++;        console.log(&quot;目前播放了&quot; + v + &quot;个视频&quot;);    }});</code><br>按回车运行js代码,（代码于2019.3.24号优化更新）之后电脑就会自己刷课<br>虽然代码有静音操作，但是还是建议把声音关了，因为时不时会bug一下出声</p>]]></content>
      
      
      <categories>
          
          <category> 刷课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网课 </tag>
            
            <tag> 秘籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helloworld——文档样式展示</title>
      <link href="/2019/05/18/hello-world/"/>
      <url>/2019/05/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
